{
  "comments": [
    {
      "key": {
        "uuid": "7f830d9f_acad279e",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/AutoReloadRunnable.java",
        "patchSetId": 5
      },
      "lineNbr": 77,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2019-06-12T09:55:49Z",
      "side": 1,
      "message": "Can we have the same coding style for the same thing (iteration over configListeners) in both methods?",
      "range": {
        "startLine": 68,
        "startChar": 0,
        "endLine": 77,
        "endChar": 1
      },
      "revId": "0788c3c41c014359d8f2c2927a7cbabc75fb7f01",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7239eda2_1d0f7fd2",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/AutoReloadRunnable.java",
        "patchSetId": 5
      },
      "lineNbr": 77,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2019-06-12T19:03:03Z",
      "side": 1,
      "message": "we can\u0027t use the forEach() with lambdas that can throw exceptions :-(\nI need to align with the traditional for/loop",
      "parentUuid": "7f830d9f_acad279e",
      "range": {
        "startLine": 68,
        "startChar": 0,
        "endLine": 77,
        "endChar": 1
      },
      "tag": "autogenerated:gerrit:newPatchSet",
      "revId": "0788c3c41c014359d8f2c2927a7cbabc75fb7f01",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "aacfdef5_b86875e2",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/DestinationsCollection.java",
        "patchSetId": 5
      },
      "lineNbr": 57,
      "author": {
        "id": 1072905
      },
      "writtenOn": "2019-06-07T16:48:26Z",
      "side": 1,
      "message": "this does not need to be an instance variable, it is only used in allDestinations() method",
      "range": {
        "startLine": 57,
        "startChar": 2,
        "endLine": 57,
        "endChar": 36
      },
      "revId": "0788c3c41c014359d8f2c2927a7cbabc75fb7f01",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3d909534_57345d0b",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/DestinationsCollection.java",
        "patchSetId": 5
      },
      "lineNbr": 57,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2019-06-12T19:07:35Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "aacfdef5_b86875e2",
      "range": {
        "startLine": 57,
        "startChar": 2,
        "endLine": 57,
        "endChar": 36
      },
      "revId": "0788c3c41c014359d8f2c2927a7cbabc75fb7f01",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4d02ff46_6ae1ffca",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/DestinationsCollection.java",
        "patchSetId": 5
      },
      "lineNbr": 65,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2019-06-12T09:55:49Z",
      "side": 1,
      "message": "Why do we need Provider here? Isn\u0027t ReplicationQueue bound as a singleton?",
      "revId": "0788c3c41c014359d8f2c2927a7cbabc75fb7f01",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "353a5db4_9905121a",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/DestinationsCollection.java",
        "patchSetId": 5
      },
      "lineNbr": 65,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2019-06-12T19:07:35Z",
      "side": 1,
      "message": "This Provider\u003c\u003e is purely to workaround on the Guice circular dependencies issue.",
      "parentUuid": "4d02ff46_6ae1ffca",
      "revId": "0788c3c41c014359d8f2c2927a7cbabc75fb7f01",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f15e2256_02673f0d",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationModule.java",
        "patchSetId": 5
      },
      "lineNbr": 79,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2019-06-12T09:55:49Z",
      "side": 1,
      "message": "Supporting multiple listeners does not seem to be a topic of this change. I would propose\nto address this topic into an own change. We may want to consider using Guava\u0027s EventBus\nfor this purpose instead of the explicit handling of the listeners like it is done in this change.",
      "range": {
        "startLine": 78,
        "startChar": 0,
        "endLine": 79,
        "endChar": 96
      },
      "revId": "0788c3c41c014359d8f2c2927a7cbabc75fb7f01",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "16ad0aaf_bc09b703",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationModule.java",
        "patchSetId": 5
      },
      "lineNbr": 79,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2019-06-12T19:13:53Z",
      "side": 1,
      "message": "I could move to a separate change, however, it won\u0027t be clear why it is needed without the code in this change.\n\nWith regards to EventBus, I believe is a good idea and it would deserve a follow-up change for that.\nIt would be nice also to introduce in Gerrit and making it pluggable.\n\nIt has already been discussed and agreed in the conferences that Gerrit needs an event-bus and should not necessarily be inside the Gerrit JVM and potentially externalizable.\n\nOnce that interface is in place, it is definitely a good idea to reuse it here also.\n\nWDYT?",
      "parentUuid": "f15e2256_02673f0d",
      "range": {
        "startLine": 78,
        "startChar": 0,
        "endLine": 79,
        "endChar": 96
      },
      "revId": "0788c3c41c014359d8f2c2927a7cbabc75fb7f01",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6b086159_2b337be2",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationModule.java",
        "patchSetId": 5
      },
      "lineNbr": 79,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2019-06-13T09:16:24Z",
      "side": 1,
      "message": "\u003e I could move to a separate change, however, it won\u0027t be clear why it is needed without the code in this change.\n\nYou could mention it in the commit message ;-)\n\n\u003e \n\u003e With regards to EventBus, I believe is a good idea and it would deserve a follow-up change for that.\n\u003e It would be nice also to introduce in Gerrit and making it pluggable.\n\u003e \n\u003e It has already been discussed and agreed in the conferences that Gerrit needs an event-bus and should not necessarily be inside the Gerrit JVM and potentially externalizable.\n\nThese are really two completely different topics. Guava\u0027s EventBus [1] is not a general-purpose publish-subscribe system, nor is it intended for interprocess communication.  It is designed exclusively to replace traditional Java in-process event distribution using explicit registration.\n\nWith the Guava EventBus we would decouple event producer(s), the AutoReloadRunnable,\nfrom the listeners. The AutoReloadRunnable wouldn\u0027t need to be explicitly aware of the\ncollection of listeners. It would just publish an event like:\n\n  EventBus.post(new ReplicationConfigChanged(oldCfg, newCfg));\n\nThe other advantages of the EventBus over explicit listener registration are discussed in [1].\n\n[1] https://github.com/google/guava/wiki/EventBusExplained\n\n\u003e \n\u003e Once that interface is in place, it is definitely a good idea to reuse it here also.\n\u003e \n\u003e WDYT?",
      "parentUuid": "16ad0aaf_bc09b703",
      "range": {
        "startLine": 78,
        "startChar": 0,
        "endLine": 79,
        "endChar": 96
      },
      "revId": "0788c3c41c014359d8f2c2927a7cbabc75fb7f01",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f9d96267_dc53b05a",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationModule.java",
        "patchSetId": 5
      },
      "lineNbr": 79,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2019-06-13T13:05:48Z",
      "side": 1,
      "message": "\u003e \u003e I could move to a separate change, however, it won\u0027t be clear why it is needed without the code in this change.\n\u003e \n\u003e You could mention it in the commit message ;-)\n\nYes, will do.\n\n\u003e These are really two completely different topics. Guava\u0027s EventBus [1] is not a general-purpose publish-subscribe system, nor is it intended for interprocess communication.  It is designed exclusively to replace traditional Java in-process event distribution using explicit registration.\n\u003e \n\u003e With the Guava EventBus we would decouple event producer(s), the AutoReloadRunnable,\n\u003e from the listeners. The AutoReloadRunnable wouldn\u0027t need to be explicitly aware of the\n\u003e collection of listeners. It would just publish an event like:\n\u003e \n\u003e   EventBus.post(new ReplicationConfigChanged(oldCfg, newCfg));\n\nEventBus is a pub/sub where the publisher is unaware of what the subscriber is doing. Here the publisher needs to abort the reload if one of the listeners thinks that the new configuration isn\u0027t good.\n\nHowever, for Gerrit in general, EventBus is interesting indeed.\n\n\u003e \n\u003e The other advantages of the EventBus over explicit listener registration are discussed in [1].\n\u003e \n\u003e [1] https://github.com/google/guava/wiki/EventBusExplained\n\u003e \n\nI\u0027ve looked at the documentation and I believe it is not useful in this case. However, if you find a way to make the listener report back exceptions to the event generator, just let me know and I\u0027ll look into it :-)",
      "parentUuid": "6b086159_2b337be2",
      "range": {
        "startLine": 78,
        "startChar": 0,
        "endLine": 79,
        "endChar": 96
      },
      "revId": "0788c3c41c014359d8f2c2927a7cbabc75fb7f01",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c13316d5_6ab924e4",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationModule.java",
        "patchSetId": 5
      },
      "lineNbr": 79,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2019-06-13T13:58:49Z",
      "side": 1,
      "message": "\u003e \n\u003e EventBus is a pub/sub where the publisher is unaware of what the subscriber is doing. Here the publisher needs to abort the reload if one of the listeners thinks that the new configuration isn\u0027t good.\n\nHow would that work with the current design? You do not know what listeners will do\nas we notify them that the configuration has changed. If we have more than one listener\nthen some of them may reach on the reloaded configuration and already mutate some of\ntheir state or trigger destination restarts etc... and then the next listener may\ndecide that the configuration is invalid. Then we stop invoking the rest of the listeners?!\nSo we may end up with a subset of listeners looking at the new configuration and another\nsubset looking at the old configuration.\n\nI think that once we start notifying the listeners that the configuration has changed\nwe cannot rollback. Therefore, any validation of the new configuration needs to happen\nbefore we start notifying the listeners which may mutate the state.\n\nDo we really need the concept of the validation listeners? I don\u0027t know. Depends on what\nyou wanted to validate. Maybe it is enough to start with the hardcoded validation code \nin the AutoReloadRunnable and only extend the validation concept if it turns out to be really\nnecessary?\n\nAnyway, you are refactoring the existing code and you do not need to introduce concepts\nwhich we didn\u0027t have before (like validation listeners)?\n\n\u003e \n\u003e However, for Gerrit in general, EventBus is interesting indeed.\n\u003e \n\u003e \u003e \n\u003e \u003e The other advantages of the EventBus over explicit listener registration are discussed in [1].\n\u003e \u003e \n\u003e \u003e [1] https://github.com/google/guava/wiki/EventBusExplained\n\u003e \u003e \n\u003e \n\u003e I\u0027ve looked at the documentation and I believe it is not useful in this case. However, if you find a way to make the listener report back exceptions to the event generator, just let me know and I\u0027ll look into it :-)",
      "parentUuid": "f9d96267_dc53b05a",
      "range": {
        "startLine": 78,
        "startChar": 0,
        "endLine": 79,
        "endChar": 96
      },
      "revId": "0788c3c41c014359d8f2c2927a7cbabc75fb7f01",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5db3a8c7_5eabe3b8",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationQueue.java",
        "patchSetId": 5
      },
      "lineNbr": 55,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2019-06-12T09:55:49Z",
      "side": 1,
      "message": "Why do we need to inject Provider here?",
      "revId": "0788c3c41c014359d8f2c2927a7cbabc75fb7f01",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8e6c1b0a_9d255b24",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationQueue.java",
        "patchSetId": 5
      },
      "lineNbr": 55,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2019-06-12T19:13:53Z",
      "side": 1,
      "message": "Yes, for the same reason that the Provider\u003cReplicationQueue\u003e is needed in the ReplicationDestination.\n\nHaving a Provider\u003c\u003e allows resolving the circular dependency in Guice.",
      "parentUuid": "5db3a8c7_5eabe3b8",
      "revId": "0788c3c41c014359d8f2c2927a7cbabc75fb7f01",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    }
  ]
}