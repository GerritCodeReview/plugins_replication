{
  "comments": [
    {
      "key": {
        "uuid": "7f830d9f_acad279e",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/AutoReloadRunnable.java",
        "patchSetId": 5
      },
      "lineNbr": 77,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2019-06-12T09:55:49Z",
      "side": 1,
      "message": "Can we have the same coding style for the same thing (iteration over configListeners) in both methods?",
      "range": {
        "startLine": 68,
        "startChar": 0,
        "endLine": 77,
        "endChar": 1
      },
      "revId": "0788c3c41c014359d8f2c2927a7cbabc75fb7f01",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7239eda2_1d0f7fd2",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/AutoReloadRunnable.java",
        "patchSetId": 5
      },
      "lineNbr": 77,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2019-06-12T19:03:03Z",
      "side": 1,
      "message": "we can\u0027t use the forEach() with lambdas that can throw exceptions :-(\nI need to align with the traditional for/loop",
      "parentUuid": "7f830d9f_acad279e",
      "range": {
        "startLine": 68,
        "startChar": 0,
        "endLine": 77,
        "endChar": 1
      },
      "tag": "autogenerated:gerrit:newPatchSet",
      "revId": "0788c3c41c014359d8f2c2927a7cbabc75fb7f01",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "aacfdef5_b86875e2",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/DestinationsCollection.java",
        "patchSetId": 5
      },
      "lineNbr": 57,
      "author": {
        "id": 1072905
      },
      "writtenOn": "2019-06-07T16:48:26Z",
      "side": 1,
      "message": "this does not need to be an instance variable, it is only used in allDestinations() method",
      "range": {
        "startLine": 57,
        "startChar": 2,
        "endLine": 57,
        "endChar": 36
      },
      "revId": "0788c3c41c014359d8f2c2927a7cbabc75fb7f01",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3d909534_57345d0b",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/DestinationsCollection.java",
        "patchSetId": 5
      },
      "lineNbr": 57,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2019-06-12T19:07:35Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "aacfdef5_b86875e2",
      "range": {
        "startLine": 57,
        "startChar": 2,
        "endLine": 57,
        "endChar": 36
      },
      "revId": "0788c3c41c014359d8f2c2927a7cbabc75fb7f01",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4d02ff46_6ae1ffca",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/DestinationsCollection.java",
        "patchSetId": 5
      },
      "lineNbr": 65,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2019-06-12T09:55:49Z",
      "side": 1,
      "message": "Why do we need Provider here? Isn\u0027t ReplicationQueue bound as a singleton?",
      "revId": "0788c3c41c014359d8f2c2927a7cbabc75fb7f01",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "353a5db4_9905121a",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/DestinationsCollection.java",
        "patchSetId": 5
      },
      "lineNbr": 65,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2019-06-12T19:07:35Z",
      "side": 1,
      "message": "This Provider\u003c\u003e is purely to workaround on the Guice circular dependencies issue.",
      "parentUuid": "4d02ff46_6ae1ffca",
      "revId": "0788c3c41c014359d8f2c2927a7cbabc75fb7f01",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f15e2256_02673f0d",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationModule.java",
        "patchSetId": 5
      },
      "lineNbr": 79,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2019-06-12T09:55:49Z",
      "side": 1,
      "message": "Supporting multiple listeners does not seem to be a topic of this change. I would propose\nto address this topic into an own change. We may want to consider using Guava\u0027s EventBus\nfor this purpose instead of the explicit handling of the listeners like it is done in this change.",
      "range": {
        "startLine": 78,
        "startChar": 0,
        "endLine": 79,
        "endChar": 96
      },
      "revId": "0788c3c41c014359d8f2c2927a7cbabc75fb7f01",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "16ad0aaf_bc09b703",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationModule.java",
        "patchSetId": 5
      },
      "lineNbr": 79,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2019-06-12T19:13:53Z",
      "side": 1,
      "message": "I could move to a separate change, however, it won\u0027t be clear why it is needed without the code in this change.\n\nWith regards to EventBus, I believe is a good idea and it would deserve a follow-up change for that.\nIt would be nice also to introduce in Gerrit and making it pluggable.\n\nIt has already been discussed and agreed in the conferences that Gerrit needs an event-bus and should not necessarily be inside the Gerrit JVM and potentially externalizable.\n\nOnce that interface is in place, it is definitely a good idea to reuse it here also.\n\nWDYT?",
      "parentUuid": "f15e2256_02673f0d",
      "range": {
        "startLine": 78,
        "startChar": 0,
        "endLine": 79,
        "endChar": 96
      },
      "revId": "0788c3c41c014359d8f2c2927a7cbabc75fb7f01",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6b086159_2b337be2",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationModule.java",
        "patchSetId": 5
      },
      "lineNbr": 79,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2019-06-13T09:16:24Z",
      "side": 1,
      "message": "\u003e I could move to a separate change, however, it won\u0027t be clear why it is needed without the code in this change.\n\nYou could mention it in the commit message ;-)\n\n\u003e \n\u003e With regards to EventBus, I believe is a good idea and it would deserve a follow-up change for that.\n\u003e It would be nice also to introduce in Gerrit and making it pluggable.\n\u003e \n\u003e It has already been discussed and agreed in the conferences that Gerrit needs an event-bus and should not necessarily be inside the Gerrit JVM and potentially externalizable.\n\nThese are really two completely different topics. Guava\u0027s EventBus [1] is not a general-purpose publish-subscribe system, nor is it intended for interprocess communication.  It is designed exclusively to replace traditional Java in-process event distribution using explicit registration.\n\nWith the Guava EventBus we would decouple event producer(s), the AutoReloadRunnable,\nfrom the listeners. The AutoReloadRunnable wouldn\u0027t need to be explicitly aware of the\ncollection of listeners. It would just publish an event like:\n\n  EventBus.post(new ReplicationConfigChanged(oldCfg, newCfg));\n\nThe other advantages of the EventBus over explicit listener registration are discussed in [1].\n\n[1] https://github.com/google/guava/wiki/EventBusExplained\n\n\u003e \n\u003e Once that interface is in place, it is definitely a good idea to reuse it here also.\n\u003e \n\u003e WDYT?",
      "parentUuid": "16ad0aaf_bc09b703",
      "range": {
        "startLine": 78,
        "startChar": 0,
        "endLine": 79,
        "endChar": 96
      },
      "revId": "0788c3c41c014359d8f2c2927a7cbabc75fb7f01",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f9d96267_dc53b05a",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationModule.java",
        "patchSetId": 5
      },
      "lineNbr": 79,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2019-06-13T13:05:48Z",
      "side": 1,
      "message": "\u003e \u003e I could move to a separate change, however, it won\u0027t be clear why it is needed without the code in this change.\n\u003e \n\u003e You could mention it in the commit message ;-)\n\nYes, will do.\n\n\u003e These are really two completely different topics. Guava\u0027s EventBus [1] is not a general-purpose publish-subscribe system, nor is it intended for interprocess communication.  It is designed exclusively to replace traditional Java in-process event distribution using explicit registration.\n\u003e \n\u003e With the Guava EventBus we would decouple event producer(s), the AutoReloadRunnable,\n\u003e from the listeners. The AutoReloadRunnable wouldn\u0027t need to be explicitly aware of the\n\u003e collection of listeners. It would just publish an event like:\n\u003e \n\u003e   EventBus.post(new ReplicationConfigChanged(oldCfg, newCfg));\n\nEventBus is a pub/sub where the publisher is unaware of what the subscriber is doing. Here the publisher needs to abort the reload if one of the listeners thinks that the new configuration isn\u0027t good.\n\nHowever, for Gerrit in general, EventBus is interesting indeed.\n\n\u003e \n\u003e The other advantages of the EventBus over explicit listener registration are discussed in [1].\n\u003e \n\u003e [1] https://github.com/google/guava/wiki/EventBusExplained\n\u003e \n\nI\u0027ve looked at the documentation and I believe it is not useful in this case. However, if you find a way to make the listener report back exceptions to the event generator, just let me know and I\u0027ll look into it :-)",
      "parentUuid": "6b086159_2b337be2",
      "range": {
        "startLine": 78,
        "startChar": 0,
        "endLine": 79,
        "endChar": 96
      },
      "revId": "0788c3c41c014359d8f2c2927a7cbabc75fb7f01",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c13316d5_6ab924e4",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationModule.java",
        "patchSetId": 5
      },
      "lineNbr": 79,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2019-06-13T13:58:49Z",
      "side": 1,
      "message": "\u003e \n\u003e EventBus is a pub/sub where the publisher is unaware of what the subscriber is doing. Here the publisher needs to abort the reload if one of the listeners thinks that the new configuration isn\u0027t good.\n\nHow would that work with the current design? You do not know what listeners will do\nas we notify them that the configuration has changed. If we have more than one listener\nthen some of them may reach on the reloaded configuration and already mutate some of\ntheir state or trigger destination restarts etc... and then the next listener may\ndecide that the configuration is invalid. Then we stop invoking the rest of the listeners?!\nSo we may end up with a subset of listeners looking at the new configuration and another\nsubset looking at the old configuration.\n\nI think that once we start notifying the listeners that the configuration has changed\nwe cannot rollback. Therefore, any validation of the new configuration needs to happen\nbefore we start notifying the listeners which may mutate the state.\n\nDo we really need the concept of the validation listeners? I don\u0027t know. Depends on what\nyou wanted to validate. Maybe it is enough to start with the hardcoded validation code \nin the AutoReloadRunnable and only extend the validation concept if it turns out to be really\nnecessary?\n\nAnyway, you are refactoring the existing code and you do not need to introduce concepts\nwhich we didn\u0027t have before (like validation listeners)?\n\n\u003e \n\u003e However, for Gerrit in general, EventBus is interesting indeed.\n\u003e \n\u003e \u003e \n\u003e \u003e The other advantages of the EventBus over explicit listener registration are discussed in [1].\n\u003e \u003e \n\u003e \u003e [1] https://github.com/google/guava/wiki/EventBusExplained\n\u003e \u003e \n\u003e \n\u003e I\u0027ve looked at the documentation and I believe it is not useful in this case. However, if you find a way to make the listener report back exceptions to the event generator, just let me know and I\u0027ll look into it :-)",
      "parentUuid": "f9d96267_dc53b05a",
      "range": {
        "startLine": 78,
        "startChar": 0,
        "endLine": 79,
        "endChar": 96
      },
      "revId": "0788c3c41c014359d8f2c2927a7cbabc75fb7f01",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "62405494_f3c549c4",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationModule.java",
        "patchSetId": 5
      },
      "lineNbr": 79,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2019-06-13T18:59:02Z",
      "side": 1,
      "message": "\u003e \u003e \n\u003e \u003e EventBus is a pub/sub where the publisher is unaware of what the subscriber is doing. Here the publisher needs to abort the reload if one of the listeners thinks that the new configuration isn\u0027t good.\n\u003e \n\u003e How would that work with the current design? You do not know what listeners will do\n\u003e as we notify them that the configuration has changed. If we have more than one listener\n\u003e then some of them may reach on the reloaded configuration and already mutate some of\n\u003e their state or trigger destination restarts etc... and then the next listener may\n\u003e decide that the configuration is invalid. Then we stop invoking the rest of the listeners?!\n\u003e So we may end up with a subset of listeners looking at the new configuration and another\n\u003e subset looking at the old configuration.\n\nTrue, the only listener that actually can fail is the DestinationsCollection, but you are right, it is an issue at the moment.\n\nWe need to go back to the two methods: before and after.\nIf one of the listeners fails at the before step, nobody will get the after step.\n\nOr do you see other way to solve the issue?\n\n\u003e I think that once we start notifying the listeners that the configuration has changed\n\u003e we cannot rollback.\n\nThat would be a regression compared to what happens today: if the configuration is invalid, the reload is blocked and the replication plugin will continue to work with the old config.\n\nIf we ignore that use-case, we\u0027ll create a regression.\n\n\u003e Therefore, any validation of the new configuration needs to happen\n\u003e before we start notifying the listeners which may mutate the state.\n\nOnly the listeners can validate because they have the real semantics of the configuration.\n\n\u003e Do we really need the concept of the validation listeners? I don\u0027t know. Depends on what\n\u003e you wanted to validate.\n\nYes, because before we had that use-case.\n\n\u003e Maybe it is enough to start with the hardcoded validation code \n\u003e in the AutoReloadRunnable and only extend the validation concept if it turns out to be really\n\u003e necessary?\n\nThis refactoring is about breaking down responsibilities BUT if we collapse the loading of the destinations in the AutoReloadRunnble to trigger all the config validations, then we\u0027re back to the starting blocks :-(\n\n\u003e Anyway, you are refactoring the existing code and you do not need to introduce concepts\n\u003e which we didn\u0027t have before (like validation listeners)?\n\nThe existing code covered that use-case.\nThe listeners have been introduced a per your request and thus they need to support the existing use-cases.\n\nDo you have any other ideas or opinions on how to solve the issue?",
      "parentUuid": "c13316d5_6ab924e4",
      "range": {
        "startLine": 78,
        "startChar": 0,
        "endLine": 79,
        "endChar": 96
      },
      "revId": "0788c3c41c014359d8f2c2927a7cbabc75fb7f01",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e9f4bced_a994b846",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationModule.java",
        "patchSetId": 5
      },
      "lineNbr": 79,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2019-06-14T09:25:20Z",
      "side": 1,
      "message": "\u003e \u003e How would that work with the current design? You do not know what listeners will do\n\u003e \u003e as we notify them that the configuration has changed. If we have more than one listener\n\u003e \u003e then some of them may reach on the reloaded configuration and already mutate some of\n\u003e \u003e their state or trigger destination restarts etc... and then the next listener may\n\u003e \u003e decide that the configuration is invalid. Then we stop invoking the rest of the listeners?!\n\u003e \u003e So we may end up with a subset of listeners looking at the new configuration and another\n\u003e \u003e subset looking at the old configuration.\n\u003e \n\u003e True, the only listener that actually can fail is the DestinationsCollection, but you are right, it is an issue at the moment.\n\u003e \n\u003e We need to go back to the two methods: before and after.\n\nThis wouldn\u0027t resolve the issue. Just look at how the before was implemented just before\nwe switched to onReload:\n\nhttps://gerrit-review.googlesource.com/c/plugins/replication/+/227181/8/src/main/java/com/googlesource/gerrit/plugins/replication/DestinationsCollection.java#182\n\nIt stopped all destinations. If a next listener would reject the (new) configuration\nand we do not call afterLoad, the destinations would remain stopped. No more replication.\n\nFurther, the beforeLoad method only has access to the old configuration, so it cannot\nvalidate the new configuration.\n\n\u003e If one of the listeners fails at the before step, nobody will get the after step.\n\nConsidering what I wrote above this can lead to completely stall replication.\nbefore/after is too vague. When someone implements a (new) listener how does she\nknow what to do in the before and what to do in the after method? \n\n\u003e \n\u003e Or do you see other way to solve the issue?\n\nIMHO, we need to address the following issues:\n* configuration validation before performing any mutation\n* the concept of multiple listeners\n\nThe listeners should likely have a more explicit API than just before/after load.\nMaybe something like:\n\n  interface ReplicationConfigListener {\n    void validate(ReplicationFileBasedConfig oldCfg, ReplicationFileBasedConfig newCfg) throws InvalidConfigException;\n    void reload(ReplicationFileBasedConfig oldCfg, ReplicationFileBasedConfig newCfg);\n  }\n\nI am undecided if the reload method should be part of this interface or not. We only\nneed to know about listeners when we call the validate method so that we can handle the\nexception and cancel the reload. Afterwards, we could just post an event and let the subscribers\ndo whatever they want to adjust to the new configuration.\n\nIdeally this should be addressed in a separate change which only focuses on this\nalready complex enough topic. This discussion here shows that we are discussing an\nimportant topic as a side story of this change.",
      "parentUuid": "62405494_f3c549c4",
      "range": {
        "startLine": 78,
        "startChar": 0,
        "endLine": 79,
        "endChar": 96
      },
      "revId": "0788c3c41c014359d8f2c2927a7cbabc75fb7f01",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "38099ca8_7d4ad46d",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationModule.java",
        "patchSetId": 5
      },
      "lineNbr": 79,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2019-06-14T11:53:22Z",
      "side": 1,
      "message": "\u003e This wouldn\u0027t resolve the issue. Just look at how the before was implemented just before\n\u003e we switched to onReload:\n\u003e \n\u003e https://gerrit-review.googlesource.com/c/plugins/replication/+/227181/8/src/main/java/com/googlesource/gerrit/plugins/replication/DestinationsCollection.java#182\n\u003e \n\u003e It stopped all destinations. If a next listener would reject the (new) configuration\n\u003e and we do not call afterLoad, the destinations would remain stopped. No more replication.\n\nRight, that needs to be implemented correctly as we want the replication to start again with the OLD configuration in that case.\n \n\u003e Further, the beforeLoad method only has access to the old configuration, so it cannot\n\u003e validate the new configuration.\n\nSure, that needs to be addressed.\n \n\u003e Considering what I wrote above this can lead to completely stall replication.\n\u003e before/after is too vague. When someone implements a (new) listener how does she\n\u003e know what to do in the before and what to do in the after method? \n\nThe before should be called \"validateNewConfiguration\" and then after can keep on being onReload().\n\nWe could use the EventBus for the onReload() because it\u0027s a fire-and-forget but not for the validateNewConfiguration.\n\n\u003e IMHO, we need to address the following issues:\n\u003e * configuration validation before performing any mutation\n\u003e * the concept of multiple listeners\n\nYes, those are two different concerns.\n\n\u003e \n\u003e The listeners should likely have a more explicit API than just before/after load.\n\u003e Maybe something like:\n\u003e \n\u003e   interface ReplicationConfigListener {\n\u003e     void validate(ReplicationFileBasedConfig oldCfg, ReplicationFileBasedConfig newCfg) throws InvalidConfigException;\n\u003e     void reload(ReplicationFileBasedConfig oldCfg, ReplicationFileBasedConfig newCfg);\n\u003e   }\n\nCool, that is similar to one I had in mind.\n\n\u003e I am undecided if the reload method should be part of this interface or not. We only\n\u003e need to know about listeners when we call the validate method so that we can handle the\n\u003e exception and cancel the reload. Afterward, we could just post an event and let the subscribers\n\u003e do whatever they want to adjust to the new configuration.\n\nWe should have two interfaces: ReplicationConfigValidator and ReplicationConfigListener.\nYou may want to implement only the listener and not the validator.\n \n\u003e Ideally this should be addressed in a separate change which only focuses on this\n\u003e already complex enough topic. This discussion here shows that we are discussing an\n\u003e important topic as a side story of this change.\n\nSure, let\u0027s add one specific follow-up change for that and I\u0027ll resolve this thread.",
      "parentUuid": "e9f4bced_a994b846",
      "range": {
        "startLine": 78,
        "startChar": 0,
        "endLine": 79,
        "endChar": 96
      },
      "revId": "0788c3c41c014359d8f2c2927a7cbabc75fb7f01",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "97d82fe1_0a210c92",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationModule.java",
        "patchSetId": 5
      },
      "lineNbr": 79,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2019-06-14T13:06:11Z",
      "side": 1,
      "message": "\u003e The before should be called \"validateNewConfiguration\" and then after can keep on being onReload().\n\nYes.\n\n\u003e \n\u003e We could use the EventBus for the onReload() because it\u0027s a fire-and-forget but not for the validateNewConfiguration.\n\nYes.\n\nOnce the validation is done we just fire the event. At that point we anyway cannot\ndo anything useful if one of the listeners (or subscribers in the EventBus terminology)\nruns into an error.\n\n\u003e \n\u003e \u003e IMHO, we need to address the following issues:\n\u003e \u003e * configuration validation before performing any mutation\n\u003e \u003e * the concept of multiple listeners\n\u003e \n\u003e Yes, those are two different concerns.\n\u003e \n\u003e \u003e \n\u003e \u003e The listeners should likely have a more explicit API than just before/after load.\n\u003e \u003e Maybe something like:\n\u003e \u003e \n\u003e \u003e   interface ReplicationConfigListener {\n\u003e \u003e     void validate(ReplicationFileBasedConfig oldCfg, ReplicationFileBasedConfig newCfg) throws InvalidConfigException;\n\u003e \u003e     void reload(ReplicationFileBasedConfig oldCfg, ReplicationFileBasedConfig newCfg);\n\u003e \u003e   }\n\u003e \n\u003e Cool, that is similar to one I had in mind.\n\u003e \n\u003e \u003e I am undecided if the reload method should be part of this interface or not. We only\n\u003e \u003e need to know about listeners when we call the validate method so that we can handle the\n\u003e \u003e exception and cancel the reload. Afterward, we could just post an event and let the subscribers\n\u003e \u003e do whatever they want to adjust to the new configuration.\n\u003e \n\u003e We should have two interfaces: ReplicationConfigValidator and ReplicationConfigListener.\n\u003e You may want to implement only the listener and not the validator.\n\nWe do not need the second interface if we agreed on firing event using the EventBus.",
      "parentUuid": "38099ca8_7d4ad46d",
      "range": {
        "startLine": 78,
        "startChar": 0,
        "endLine": 79,
        "endChar": 96
      },
      "revId": "0788c3c41c014359d8f2c2927a7cbabc75fb7f01",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "bd6a5c23_dba73043",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationModule.java",
        "patchSetId": 5
      },
      "lineNbr": 79,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2019-06-14T15:46:09Z",
      "side": 1,
      "message": "Cool.",
      "parentUuid": "97d82fe1_0a210c92",
      "range": {
        "startLine": 78,
        "startChar": 0,
        "endLine": 79,
        "endChar": 96
      },
      "revId": "0788c3c41c014359d8f2c2927a7cbabc75fb7f01",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5db3a8c7_5eabe3b8",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationQueue.java",
        "patchSetId": 5
      },
      "lineNbr": 55,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2019-06-12T09:55:49Z",
      "side": 1,
      "message": "Why do we need to inject Provider here?",
      "revId": "0788c3c41c014359d8f2c2927a7cbabc75fb7f01",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8e6c1b0a_9d255b24",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationQueue.java",
        "patchSetId": 5
      },
      "lineNbr": 55,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2019-06-12T19:13:53Z",
      "side": 1,
      "message": "Yes, for the same reason that the Provider\u003cReplicationQueue\u003e is needed in the ReplicationDestination.\n\nHaving a Provider\u003c\u003e allows resolving the circular dependency in Guice.",
      "parentUuid": "5db3a8c7_5eabe3b8",
      "revId": "0788c3c41c014359d8f2c2927a7cbabc75fb7f01",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    }
  ]
}