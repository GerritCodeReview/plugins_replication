{
  "comments": [
    {
      "key": {
        "uuid": "70ede0de_9474ba27",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationQueue.java",
        "patchSetId": 2
      },
      "lineNbr": 137,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2019-09-25T20:18:18Z",
      "side": 1,
      "message": "Needs to be synchronized.",
      "revId": "c106a0afddcfdaebf9b99fcfb3380c1aac98cf9d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9e268f70_3365b5d9",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationQueue.java",
        "patchSetId": 2
      },
      "lineNbr": 137,
      "author": {
        "id": 1083454
      },
      "writtenOn": "2019-09-25T21:25:59Z",
      "side": 1,
      "message": "It\u0027s a synchronized set so all the operations are thread safe we need to use synchronized block only for iteration:\nhttps://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#synchronizedSet(java.util.Set)\n\nMore detailed explanation:\nhttps://www.baeldung.com/java-synchronized-collections\n\nSynchronized collections achieve thread-safety through intrinsic locking, and the entire collections are locked. Intrinsic locking is implemented via synchronized blocks within the wrapped collection\u0027s methods.\n\nAs we might expect, synchronized collections assure data consistency/integrity in multi-threaded environments. However, they might come with a penalty in performance, as only one single thread can access the collection at a time (a.k.a. synchronized access).",
      "parentUuid": "70ede0de_9474ba27",
      "revId": "c106a0afddcfdaebf9b99fcfb3380c1aac98cf9d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8502e449_57ef71cb",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationQueue.java",
        "patchSetId": 2
      },
      "lineNbr": 137,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2019-09-25T21:36:16Z",
      "side": 1,
      "message": "Thanks for the detailed explanation, however, I believe you wanted to make sure that you don\u0027t fire events at the same time that you\u0027re receiving them.\n\nThe running variable isn\u0027t protected any synchronization, so that makes technically possible that you are adding and replaying events at the same time.\n\nBest to be safe than sorry, and use a traditional synchronized on the variable IMHO.",
      "parentUuid": "9e268f70_3365b5d9",
      "revId": "c106a0afddcfdaebf9b99fcfb3380c1aac98cf9d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3cf13369_d60fcfcb",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationQueue.java",
        "patchSetId": 2
      },
      "lineNbr": 187,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2019-09-25T21:36:16Z",
      "side": 1,
      "message": "This is blocking on the collection object, however, it would require that you are putting a synchronizad(beforeStartupEventsSet) also at L137",
      "range": {
        "startLine": 187,
        "startChar": 4,
        "endLine": 187,
        "endChar": 41
      },
      "revId": "c106a0afddcfdaebf9b99fcfb3380c1aac98cf9d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "24814dae_c39774a0",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationQueue.java",
        "patchSetId": 2
      },
      "lineNbr": 193,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2019-09-25T20:18:18Z",
      "side": 1,
      "message": "We do we need this?",
      "revId": "c106a0afddcfdaebf9b99fcfb3380c1aac98cf9d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4e86ca3b_af35f798",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationQueue.java",
        "patchSetId": 2
      },
      "lineNbr": 193,
      "author": {
        "id": 1083454
      },
      "writtenOn": "2019-09-25T21:25:59Z",
      "side": 1,
      "message": "we have to remove events from the Set when we schedule them, we can do it in that way or after iteration we can do beforeStartupEventsSet.clean(). Second option is all or nothing, currently we are removing events one by one when they are processed",
      "parentUuid": "24814dae_c39774a0",
      "revId": "c106a0afddcfdaebf9b99fcfb3380c1aac98cf9d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4706245e_08064450",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationQueue.java",
        "patchSetId": 2
      },
      "lineNbr": 193,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2019-09-25T21:36:16Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "4e86ca3b_af35f798",
      "revId": "c106a0afddcfdaebf9b99fcfb3380c1aac98cf9d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    }
  ]
}