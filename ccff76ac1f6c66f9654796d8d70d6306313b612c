{
  "comments": [
    {
      "key": {
        "uuid": "113f5a2b_dc1cb246",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/AutoReloadConfigDecorator.java",
        "patchSetId": 1
      },
      "lineNbr": 81,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2019-05-15T10:36:53Z",
      "side": 1,
      "message": "This condition is always false as currentEtag is the same instance\nas the currentConfigEtag (line 78).",
      "range": {
        "startLine": 81,
        "startChar": 12,
        "endLine": 81,
        "endChar": 50
      },
      "revId": "ccff76ac1f6c66f9654796d8d70d6306313b612c",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "679ec66d_425e9e81",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/DestinationsCollection.java",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2019-05-15T10:36:53Z",
      "side": 1,
      "message": "This class is (bound as) singleton but it is not thread safe.\nFirst, it is not immutable as destinations are recomputed when the configuration changes.\nHowever, the update the the allDestinations is not properly published to other threads.\nFurther, there is also a race when two references get updated concurrently:\n\n  T1: ReplicationQueue.onGitReferenceUpdated(\"refs/heads/foo\") \u003e DestinationsCollection.getAll()\n  T2: ReplicationQueue.onGitReferenceUpdated(\"refs/heads/bar\") \u003e DestinationsCollection.getAll()\n\nBoth T1 and T2 may end up recomputing the destinations.",
      "revId": "ccff76ac1f6c66f9654796d8d70d6306313b612c",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "758ad7b5_fc0b2336",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/DestinationsCollection.java",
        "patchSetId": 1
      },
      "lineNbr": 47,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2019-05-15T10:36:53Z",
      "side": 1,
      "message": "This never changes its value",
      "revId": "ccff76ac1f6c66f9654796d8d70d6306313b612c",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ffe05391_58ca0cbf",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/DestinationsCollection.java",
        "patchSetId": 1
      },
      "lineNbr": 64,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2019-05-15T10:57:04Z",
      "side": 1,
      "message": "It is ugly that we have to call replicationConfig.getConfig in order to ensure\nthat auto reloading works. Before this change the AutoReloadConfigDecorator\nencapsulated the logic of auto reloading, including the destinations.\nThis change tries to decouple the recomputing of the destination from\nthe internals of the AutoReloadConfigDecorator, but it actually still knows\nthe internals of this particular ReplicationConfig implementation and it actively\nparticipates in its implementation by performing this call. This is not a\nproper decoupling.\n\nIf we agree on decoupling configuration auto reloading from how the destinations\nare created, then let\u0027s try to do it in such a way that implementations of these\ntwo concepts do not depend on each other.\n\nI believe that the proposed listener concept is a good idea. Maybe we can consider\nusing guava\u0027s EventBus instead of having an explicit listener interface and see\nwhich approach we like better? Whatever approach we use, the DestinationsCollection\nclass should only know that it will get notified when the configuration changes.\nThis class should never pro-actively call getConfig in order to trigger refreshing\nof the potentially changed configuration.\n\nThe auto reloading of the configuration should probably be a task which is scheduled\nto run periodically (every 1 minute for example). When it detects a changed configuration\n(by looking at the Etag) it will notify the listeners.",
      "revId": "ccff76ac1f6c66f9654796d8d70d6306313b612c",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5b71411a_bc9a5c97",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/DestinationsCollection.java",
        "patchSetId": 1
      },
      "lineNbr": 92,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2019-05-15T10:36:53Z",
      "side": 1,
      "message": "Consider the following recursive call:\n\n  (START) DestinationsCollection.startup()\n  92: loadDestinations(ReplicationConfig.getConfig())\n  92: ReplicationConfig.getConfig()   \u003e\u003e\u003e AutoReloadConfigDecorator\n  72: AutoReloadConfigDecorator.reloadIfNeeded()\n  86: configListener.get().afterLoad() \u003e\u003e\u003e DestinationsCollection.afterLoad()\n  129: DestinationsCollection.startup()  \u003e\u003e\u003e (START)\n\nSo the startup method will end up calling itself and since the started flag is never updated\nthis will end up into an infinite recursion.",
      "revId": "ccff76ac1f6c66f9654796d8d70d6306313b612c",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    }
  ]
}