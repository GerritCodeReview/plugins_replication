{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "46b16ab7_7106165e",
        "filename": "/COMMIT_MSG",
        "patchSetId": 7
      },
      "lineNbr": 20,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2021-10-29T01:39:04Z",
      "side": 1,
      "message": "If we are going to be able to split up larger pushes into smaller pushes for scaling purposes, then I would like to ensure that we do it in a way that each of the smaller pushes could potentially be done by different primaries concurrently. Does the solution offer this possibility? If not, what approach would?",
      "revId": "0fa864c56b5a408a5cfb67287c9267204fad0ea9",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d61923ac_97e29c9d",
        "filename": "/COMMIT_MSG",
        "patchSetId": 7
      },
      "lineNbr": 20,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2021-10-29T23:02:02Z",
      "side": 1,
      "message": "That is not the purpose as documented in Issue 13216. A target replication end like GitHub simply won\u0027t accept pushes with lots of refs: splitting a large push as a series of smaller and sequential pushes is the only way to replicate to those endpoints. It actually won\u0027t make it faster but slower than a single push with all the refs, but at least it will eventually succeed instead of always failing and retrying forever.\n\nPlease note that would \"solve\" a GitHub (or GitLab) problem by \"workaround\" on the Gerrit side.",
      "parentUuid": "46b16ab7_7106165e",
      "revId": "0fa864c56b5a408a5cfb67287c9267204fad0ea9",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "da8e5a55_960debe6",
        "filename": "/COMMIT_MSG",
        "patchSetId": 7
      },
      "lineNbr": 20,
      "author": {
        "id": 1025452
      },
      "writtenOn": "2021-10-30T08:03:59Z",
      "side": 1,
      "message": "But more importantly it is disabled by default and can be enabled/fine-tuned per remote.\n\n@Martin the idea is interesting but it would imply that division into batches happens on the scheduling level, gets serialised and individual batches could be picked up by any primary, right? Sounds like a lot work to me (but I could be wrong). As it was said by Luca - that is not the purpose of this change and AFAIU single master would group it back to single push :D",
      "parentUuid": "d61923ac_97e29c9d",
      "revId": "0fa864c56b5a408a5cfb67287c9267204fad0ea9",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f4df6ea2_d1f92624",
        "filename": "/COMMIT_MSG",
        "patchSetId": 7
      },
      "lineNbr": 20,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2021-10-31T23:38:41Z",
      "side": 1,
      "message": "\u003e That is not the purpose as documented in Issue 13216. A target replication end like GitHub simply won\u0027t accept pushes with lots of refs: splitting a large push as a series of smaller and sequential pushes is the only way to replicate to those endpoints. It actually won\u0027t make it faster but slower than a single push with all the refs, but at least it will eventually succeed instead of always failing and retrying forever\n\nMakes sense. Whatever approach you take, I think it is important that you ensure that the on disk data reflect whatever replication is doing, and what replication work is outstanding. This is important not only to let other primaries potentially help out, but also to ensure that benefit of splitting the refs into smaller batches not be lost by primary restarts. In another words, if you manage to replicate 9K refs out of 10K refs to a site (say in batches of 1K), and then the primary goes down, it is important that when the server starts up again, that it not try to re-replicate those 9K refs which were already successful. Does your current approach do this?",
      "parentUuid": "d61923ac_97e29c9d",
      "revId": "0fa864c56b5a408a5cfb67287c9267204fad0ea9",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d95c16d8_2ecfecd9",
        "filename": "/COMMIT_MSG",
        "patchSetId": 7
      },
      "lineNbr": 20,
      "author": {
        "id": 1025452
      },
      "writtenOn": "2021-11-02T07:49:22Z",
      "side": 1,
      "message": "AFAIU it will not be lost as `generateUpdates` asks remote for existing refs. IOW it will not try to resend 9K refs but only the remaining 1K as previous pushes succeeded. IMHO this looks like a small improvement over what we have now cuz if I\u0027m not mistaken we would push all 10K refs now... Having said that I believe that importance of having it accounted on the disk is not that important anymore ;).",
      "parentUuid": "f4df6ea2_d1f92624",
      "revId": "0fa864c56b5a408a5cfb67287c9267204fad0ea9",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ed01fa47_cad973c0",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2021-11-04T09:51:22Z",
      "side": 1,
      "message": "I believe this change would do the job, bearing in mind that isn\u0027t designed and suitable for a multi-primary setup or for a remote pushed by different sources. Possibly this needs to be highlighted in the docs.\n\nHowever, I see the points from Nasser and Martin that at least we need to make sure that under those conditions it doesn\u0027t generate inconsistencies, or at least more than the ones we have already.\n\nExample:\nTwo Gerrit primaries (not in HA, not in MS) force pushing to the same remote, they will step into each other toes overwriting each other refs regardless of this change. Therefore that isn\u0027t a valid scenario but we need to make sure that we don\u0027t make it worse.\n\n@Jacek can you check the HA scenario (multi-primary) to make sure that this change doesn\u0027t create inconsistencies?\n\nRepo with 1000 refs, batch of 10 refs, two primaries pushing at the same time. To simulate a slow remote, you can add a 10s sleep between pushes.",
      "revId": "0fa864c56b5a408a5cfb67287c9267204fad0ea9",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b8d40a1b_d3130535",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 1025452
      },
      "writtenOn": "2021-11-08T10:58:40Z",
      "side": 1,
      "message": "@Luca I have performed the following test:\n\n1. created local setup with two HA primaries (high-availability plugin) with shared folder over the local FS\n\n2. I have configured the replication plugin (slightly modified to wait 10s after each batch push) for both primaries like that\n\n  [gerrit]\n\tmaxRefsToShow \u003d 0\n  [replication]\n\teventsDirectory \u003d /tmp/gerrit-ha-replication/shared/replication_events\n  [remote \"file\"]\n\turl \u003d file:///tmp/gerrit-ha-replication/shared/test_repo.git\n\tthreads \u003d 1\n\tprojects \u003d test_repo\n\tdefaultForceUpdate \u003d true\n\treplicationDelay \u003d 10\n\tdistributionInterval \u003d 1\n\tpush \u003d +refs/heads/*:refs/heads/*\n\tpush \u003d +refs/tags/*:refs/tags/*\n\tpushBatchSize \u003d 3\n\nthe same eventsDirectory was used by both primaries\n\n3. I have cloned `test_repo` from each primary 2 times\n\n4. I have issued a loop (2 times in each repo) that was\n* crating 5 commits\n* pushing them to 8 refs (each cloned repo used different set of refs)\n* sleeping for 15s\n\nIOW each primary was replicating to 16 refs\n\n6. results:\n* as expected pushed to the same primary were consolidated into uber-push (16 refs)\n* each push was divided into 6 batches\n* batches were scoped per primary IOW once push was consolidated and put into execution division into batches had no impact on it (the other primary was not trying to push the ref/object)\n* replication destination had up to date refs (have checked all 32 refs)\n* IMHO it works as expected :)",
      "parentUuid": "ed01fa47_cad973c0",
      "revId": "0fa864c56b5a408a5cfb67287c9267204fad0ea9",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    }
  ]
}