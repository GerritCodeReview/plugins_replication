{
  "comments": [
    {
      "key": {
        "uuid": "cd6ffe04_d9c2bca3",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationModule.java",
        "patchSetId": 14
      },
      "lineNbr": 85,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2020-03-25T13:15:50Z",
      "side": 1,
      "message": "... the @Singleton annotation is removed from this class but here the SINGLETON scope is\nmissing? However, in the line 91 this class is bound with the SINGLETON scope?\nWhat\u0027s the motivation behind all of this? Why not keep the @Singleton annotation\non the ReplicationFileBasedConfig?",
      "revId": "47c65d399d200f11aac82c065575c0db6d0ca16d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fc64a6c0_4187bec9",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationModule.java",
        "patchSetId": 14
      },
      "lineNbr": 85,
      "author": {
        "id": 1083454
      },
      "writtenOn": "2020-03-25T14:11:57Z",
      "side": 1,
      "message": "I had to remove @Singleton annotation because of how Guice works. If the class is marked as a singleton even Provider\u003cReplicationConfig\u003e is returning the same instance. Please have in mind that in AutoReloadRunnable line 66 we have to get new instance when we have new configuration version. That\u0027s why for auto reload we cannot mark ReplicationFileBasedConfig as a singleton but we should mark AutoReloadConfigDecorator instead.",
      "parentUuid": "cd6ffe04_d9c2bca3",
      "revId": "47c65d399d200f11aac82c065575c0db6d0ca16d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "599ee7c8_1b263214",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationModule.java",
        "patchSetId": 14
      },
      "lineNbr": 85,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2020-03-25T14:15:57Z",
      "side": 1,
      "message": "Agreed: the configuration *may* change and thus we need to make sure to be able to access a different instance.",
      "parentUuid": "fc64a6c0_4187bec9",
      "revId": "47c65d399d200f11aac82c065575c0db6d0ca16d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f4b79dce_3cf30204",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationModule.java",
        "patchSetId": 14
      },
      "lineNbr": 85,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2020-03-25T15:31:55Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "599ee7c8_1b263214",
      "revId": "47c65d399d200f11aac82c065575c0db6d0ca16d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7824fd40_b10f7dc0",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/VanillaReplicationConfig.java",
        "patchSetId": 14
      },
      "lineNbr": 23,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2020-03-25T12:51:19Z",
      "side": 1,
      "message": "I like this name even less than ReplicationConfigImpl. This name suggests that the\nimplementation of ReplicationConfig annotated with @VanillaReplicationConfig is a kind of\ndefault/simple replication config implementation. However, if I follow correctly, this is\nnot the purpose of this annotation. The real purpose is to inject the chosen ReplicationConfig\nimplementation into the AutoReloadConfigDecorator.\n\nTo give an example, imagine we have two ReplicationConfig implementations (file and DB based):\n* ReplicationFileBasedConfig\n* RepllicationDbBasedConfig\n\nBased on a parameter, maybe a system property because we cannot use replication.config for that, we pick one of the implementations to use:\n\n  -Dreplication.config.impl\u003dcom.googlesource.gerrit.plugins.repication.ReplicationDbConfig\n\nNow, in the ReplicationModule we have to check that system property and bind the configured\nimplementation\n\n  String className \u003d System.getProperty(\"replication.config.impl\");\n  bind(ReplicationConfig.class)\n          .annotatedWith(VanillaReplicationConfig.class)\n          .to(Class.forName(className));\n\nObviously, the usage of the Vanilla... annotation name is wrong.\nWhat this annotation represents is the currently configured replication configuration implementation. Therefore, the ReplicationConfigImpl is a better name for this purpose\neven if it is not perfect... however ATM I don\u0027t have a better proposal.",
      "range": {
        "startLine": 23,
        "startChar": 18,
        "endLine": 23,
        "endChar": 42
      },
      "revId": "47c65d399d200f11aac82c065575c0db6d0ca16d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cbb0b030_4dbb3981",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/VanillaReplicationConfig.java",
        "patchSetId": 14
      },
      "lineNbr": 23,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2020-03-25T14:15:57Z",
      "side": 1,
      "message": "\u003e I like this name even less than ReplicationConfigImpl. This name suggests that the\n\u003e implementation of ReplicationConfig annotated with @VanillaReplicationConfig is a kind of\n\u003e default/simple replication config implementation. However, if I follow correctly, this is\n\u003e not the purpose of this annotation. The real purpose is to inject the chosen ReplicationConfig\n\u003e implementation into the AutoReloadConfigDecorator.\n\nThe \"vanilla\" implementation, without decoration. Can you suggest a more sensible name?\n\n\u003e \n\u003e To give an example, imagine we have two ReplicationConfig implementations (file and DB based):\n\u003e * ReplicationFileBasedConfig\n\u003e * RepllicationDbBasedConfig\n\nThe above use-case isn\u0027t possible today, but I agree it will be nice to have it in the future.\n\n\u003e Based on a parameter, maybe a system property because we cannot use replication.config for that, we pick one of the implementations to use:\n\u003e \n\u003e   -Dreplication.config.impl\u003dcom.googlesource.gerrit.plugins.repication.ReplicationDbConfig\n\nGood idea, shall we do that in a follow-up change? One change \u003d one thing.\n\n\u003e Now, in the ReplicationModule we have to check that system property and bind the configured\n\u003e implementation\n\u003e \n\u003e   String className \u003d System.getProperty(\"replication.config.impl\");\n\u003e   bind(ReplicationConfig.class)\n\u003e           .annotatedWith(VanillaReplicationConfig.class)\n\u003e           .to(Class.forName(className));\n\u003e \n\u003e Obviously, the usage of the Vanilla... annotation name is wrong.\n\u003e What this annotation represents is the currently configured replication configuration implementation. Therefore, the ReplicationConfigImpl is a better name for this purpose\n\u003e even if it is not perfect... however ATM I don\u0027t have a better proposal.\n\nApart from personal preferences (I like red, you like blue, those are both nice colors to us), a name should be representative of the entity. An annotation is not an implementation and therefore we should drop the \u0027Impl\u0027 suffix. I am open to any other suggestion, as long as the name helps understanding what is the entity it represents.",
      "parentUuid": "7824fd40_b10f7dc0",
      "range": {
        "startLine": 23,
        "startChar": 18,
        "endLine": 23,
        "endChar": 42
      },
      "revId": "47c65d399d200f11aac82c065575c0db6d0ca16d",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    }
  ]
}