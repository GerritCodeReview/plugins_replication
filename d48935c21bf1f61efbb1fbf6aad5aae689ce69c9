{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "99f04492_9b863b6f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 8
      },
      "lineNbr": 0,
      "author": {
        "id": 1002666
      },
      "writtenOn": "2020-06-25T16:05:37Z",
      "side": 1,
      "message": "Sorry, realized I used the wrong formatter version before.",
      "revId": "d48935c21bf1f61efbb1fbf6aad5aae689ce69c9",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d8574184_b3321ca2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 8
      },
      "lineNbr": 0,
      "author": {
        "id": 1002666
      },
      "writtenOn": "2020-06-26T19:10:59Z",
      "side": 1,
      "message": "Sven, since you can +2, can you clarify why you didn\u0027t? That would help me address any remaining concerns.",
      "revId": "d48935c21bf1f61efbb1fbf6aad5aae689ce69c9",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "807a1edd_56cb20cd",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 8
      },
      "lineNbr": 0,
      "author": {
        "id": 1014252
      },
      "writtenOn": "2020-06-29T09:15:04Z",
      "side": 1,
      "message": "CR+1 \u003d LGTM but someone else must approve.\n\nI feel that I currently do not have sufficiently deep knowledge of the replication plugin to set CR+2 by myself.\n\nTogether with the previous CR+1 from David P it was proposed that Luca should take a look at it, and Luca was reluctant to score it due to it lacking test-case(s) for the new implementation I got the impression that this discussion isn\u0027t concluded and IMO Luca has far greater insight into the current state of this plugin than I have.",
      "parentUuid": "d8574184_b3321ca2",
      "revId": "d48935c21bf1f61efbb1fbf6aad5aae689ce69c9",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8115ae03_0abad76f",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ChainedScheduler.java",
        "patchSetId": 8
      },
      "lineNbr": 27,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2020-07-13T16:20:04Z",
      "side": 1,
      "message": "I am struggling to see which code in this class implements this policy. Maybe I don\u0027t\nunderstand what \"outstanding and waiting\" means here...\n\nIIUC, when scheduling we wrap into Chainer and Chainer.run() will first call next() which\nwill schedule another Chainer before executing the wrapped item.\n\nIf the thread pool is of size N then we can end up with N items being executed (concurrently) and N waiting in the executors queue, right? So it is not 1 outstanding but N outstanding?",
      "range": {
        "startLine": 26,
        "startChar": 72,
        "endLine": 27,
        "endChar": 92
      },
      "revId": "d48935c21bf1f61efbb1fbf6aad5aae689ce69c9",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5031dc05_553b399b",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ChainedScheduler.java",
        "patchSetId": 8
      },
      "lineNbr": 27,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2020-07-13T17:22:44Z",
      "side": 1,
      "message": "\u003e I am struggling to see which code in this class implements this policy. Maybe I don\u0027t\n\u003e understand what \"outstanding and waiting\" means here...\n\u003e \n\u003e IIUC, when scheduling we wrap into Chainer and Chainer.run() will first call next() which\n\u003e will schedule another Chainer before executing the wrapped item.\n\u003e \n\u003e If the thread pool is of size N then we can end up with N items being executed (concurrently) and N waiting in the executors queue, right? So it is not 1 outstanding but N outstanding?\n\nMy description is correct, there will only ever be 1 outstanding, not N. In order to queue one, the current queued one has to run and thus it can no longer be queued itself. The beauty of this is that if there are empty threads then you can get as many running as there are threads, but even when that happens, only 1 will be queued.",
      "parentUuid": "8115ae03_0abad76f",
      "range": {
        "startLine": 26,
        "startChar": 72,
        "endLine": 27,
        "endChar": 92
      },
      "revId": "d48935c21bf1f61efbb1fbf6aad5aae689ce69c9",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b3a6c8f5_d3b31ae8",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ChainedScheduler.java",
        "patchSetId": 8
      },
      "lineNbr": 27,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2020-10-28T22:58:02Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "5031dc05_553b399b",
      "range": {
        "startLine": 26,
        "startChar": 72,
        "endLine": 27,
        "endChar": 92
      },
      "revId": "d48935c21bf1f61efbb1fbf6aad5aae689ce69c9",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    }
  ]
}