{
  "comments": [
    {
      "key": {
        "uuid": "bb1ddf0b_abbfb32b",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/DestinationsCollection.java",
        "patchSetId": 8
      },
      "lineNbr": 60,
      "author": {
        "id": 1072905
      },
      "writtenOn": "2019-04-11T10:09:04Z",
      "side": 1,
      "message": "Is there any reason why we explicitly call load() here?\n\nreloadIfNeeded() _already_ causes the configuration to be reloaded down the stack when DestinationsCollection.startup() method is invoked at L94.\n\nCalling load() explicitly here in getAll() method causes a new set of Destination objects to be created, which, haven\u0027t been started() and therefore have no poll queue available.\n\nBecause of this when the configuration is reloaded you\u0027ll get a NPE. An example here below:\n\n10:53 $ ssh -p 29777 admin@localhost replication start --all --wait\nError: Cannot enumerate known projects\nNothing to replicate\n\n[2019-04-11 10:53:50,903] [] Cannot enumerate known projects\njava.lang.NullPointerException\n\tat com.googlesource.gerrit.plugins.replication.Destination.schedule(Destination.java:372)\n\tat com.googlesource.gerrit.plugins.replication.ReplicationQueue.scheduleFullSync(ReplicationQueue.java:129)\n\tat com.googlesource.gerrit.plugins.replication.PushAll.run(PushAll.java:70)\n\tat com.google.gerrit.server.logging.LoggingContextAwareRunnable.run(LoggingContextAwareRunnable.java:83)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)\n\tat java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)\n\tat com.google.gerrit.server.git.WorkQueue$Task.run(WorkQueue.java:646)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748) \n\n\nUnless I am missing something, I think the implementation of getAll() could simply boil down to:\n\n  public List\u003cSource\u003e getAll() {\n    replicationConfig.reloadIfNeeded();\n    return sources.stream().filter(Objects::nonNull).collect(toList());\n  }\n\nthoughts?",
      "revId": "106002dc6164bf3aa3df9ad66c8264f57aa3a47f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5ec6d926_2289714b",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/DestinationsCollection.java",
        "patchSetId": 8
      },
      "lineNbr": 60,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2019-04-11T10:56:46Z",
      "side": 1,
      "message": "the reloadIfNeeded() reloads the configuration, NOT the list of destinations. Hence, the call to load() is needed.\n\nThe NPE you get is for another reason: before the stop/start was done by the configuration reloader, which was the right place because of the configuration doing *everything*.\n\nNow the stop/start needs to be done by the collection, which has full control over the destinations.",
      "parentUuid": "bb1ddf0b_abbfb32b",
      "revId": "106002dc6164bf3aa3df9ad66c8264f57aa3a47f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "14bb72f6_ab81b336",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/DestinationsCollection.java",
        "patchSetId": 8
      },
      "lineNbr": 60,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2019-04-11T11:51:48Z",
      "side": 1,
      "message": "The problem is now addressed:\n- Stop the replication queue\n- Reload the destinations\n- Start the replication queue again\n\n@Tony can you please re-check?",
      "parentUuid": "5ec6d926_2289714b",
      "revId": "106002dc6164bf3aa3df9ad66c8264f57aa3a47f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "718a6c38_4e6a3575",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/DestinationsCollection.java",
        "patchSetId": 8
      },
      "lineNbr": 60,
      "author": {
        "id": 1072905
      },
      "writtenOn": "2019-04-11T12:50:33Z",
      "side": 1,
      "message": "Yep this works as expected now, thanks Luca",
      "parentUuid": "14bb72f6_ab81b336",
      "revId": "106002dc6164bf3aa3df9ad66c8264f57aa3a47f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9713f1bb_099f0301",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationConfig.java",
        "patchSetId": 8
      },
      "lineNbr": 33,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2019-04-11T11:18:19Z",
      "side": 1,
      "message": "Based on the last comment from Antonio, I wonder if this method needs to be\nexposed by this interface.\nWhy do we have the AutoReloadConfigDecorator? Because it knows when the reload is needed\nand does that automatically, as its internal implementation detail.\nWhat does it mean to expose reloadIfNeeded from the AutoReloadConfigDecorator?\n\nCan we remove this method from this interface and let each ReplicationConfig implementation\nhandle reloads as their implementation detail?",
      "revId": "106002dc6164bf3aa3df9ad66c8264f57aa3a47f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b6b7d4ec_1d060bad",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationConfig.java",
        "patchSetId": 8
      },
      "lineNbr": 33,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2019-04-11T11:46:44Z",
      "side": 1,
      "message": "yes, I believe that is a good point.\n\nThe question is: do we want to make this refactoring even bigger? Or can we then tackles the auto-reload mechanism and put the right methods in the right place there as a separate rectoring follow-up?\n\nMy mantra with code-reviews is always: 1 change \u003d 1 thing \u003d 1 benefit, as much as possible.",
      "parentUuid": "9713f1bb_099f0301",
      "revId": "106002dc6164bf3aa3df9ad66c8264f57aa3a47f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7b64737d_791b781f",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationConfig.java",
        "patchSetId": 8
      },
      "lineNbr": 33,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2019-04-11T12:56:08Z",
      "side": 1,
      "message": "I agree with your mantra :-)\n\nHowever, this refactoring extended the API of this interface which made some existing\ncode look weird (like I wrote in my previous comment).\n\nThe auto-reload mechanism needs definitely to be tackled. The AutoReloadConfigDecorator\nwas IMHO not the best way to implement it. Among other things it depends on the\nother concrete class implementing the ReplicationConfig interface (ReplicationFileBasedConfig).\nFurther, auto-reload logic should be factored out and only provide a mean to (re)load the configuration and notify listeners when the configuration changes. We could also tackle\nthis topic during the hackathon.",
      "parentUuid": "b6b7d4ec_1d060bad",
      "revId": "106002dc6164bf3aa3df9ad66c8264f57aa3a47f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    }
  ]
}