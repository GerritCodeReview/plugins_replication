{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "a090b2b4_c3d98640",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationQueue.java",
        "patchSetId": 8
      },
      "lineNbr": 215,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2020-06-29T14:00:55Z",
      "side": 0,
      "message": "Let me try to move discussion on this change forward by first describing my understanding of this change. The main problem here is that this code snippet (firePendingEvents) is executed\nsynchronously, from that calling thread. When there are thousands of events to reschedule this can take a lot of time (at least in Qualcomm\u0027s case).\n\nThe proposed solution in this change is to move scheduling into background so that the start() method returns as fast as possible and that the replication plugin can start processing events.\nSo far, I believe that everyone agrees on the proposed concept :-)\n\nBesides moving this code into background this change also tries to act non-invasively on the default queue. This means that it wants to keep a thread from the default queue busy only\nfor a short time needed to schedule one task and then schedule the next task. To achieve that\nit introduced the concepts of: ChainedScheduled, Runner, DecoratedRunner, StreamScheduler, etc.. This code defines decorated tasks with the onDone callback used to schedule the next task. The code seems to be technically correct but it also introduces a lot of new low-level\nconstructs which makes reviewers unsure whether to submit this change.\n\nAs an alternative possibility I would like to propose the following: what if the firePendingEvents method is executed whole as one task in the default queue?\nIt is definitely more invasive towards the default queue as it would keep one thread busy\nuntil all pending tasks are rescheduled. However, if this is really an issue we can\nsimply increase the size of the default queue by one, see execution.defaultThreadPoolSize [1].\nThis solution is technically not as good as the one proposed in this change but we don\u0027t\nend up with several new low-level constructs (listed above).\n\nWDYT?\n\n[1] https://gerrit-review.googlesource.com/Documentation/config-gerrit.html#execution.defaultThreadPoolSize",
      "range": {
        "startLine": 198,
        "startChar": 0,
        "endLine": 215,
        "endChar": 5
      },
      "revId": "815d1f5626761e03e46e0efb7bc4cf91d8b9732f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d7c9eae0_441b3662",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationQueue.java",
        "patchSetId": 8
      },
      "lineNbr": 215,
      "author": {
        "id": 1002666
      },
      "writtenOn": "2020-06-29T18:52:59Z",
      "side": 0,
      "message": "[snip]\n\nThanks for this summary Saša!\n\n\u003e As an alternative possibility I would like to propose the following: what if the firePendingEvents method is executed whole as one task in the default queue?\n\u003e It is definitely more invasive towards the default queue as it would keep one thread busy\n\u003e until all pending tasks are rescheduled. However, if this is really an issue we can\n\u003e simply increase the size of the default queue by one, see execution.defaultThreadPoolSize [1].\n\u003e This solution is technically not as good as the one proposed in this change but we don\u0027t\n\u003e end up with several new low-level constructs (listed above).\n\u003e \n\u003e WDYT?\n\nYes, we definitely could do this and we did consider it. I even backported the changes to support setting defaultThreadPoolSize to 2.7 so that we could potentially do that on our fork (in case it wasn\u0027t clear before, we\u0027ve adapted our 2.7 fork and 3.2 version of the replication plugin to run together). I don\u0027t prefer this as it\u0027s basically saying we have to use more threads.\n\nThis also doesn\u0027t provide a path to the next change [2] in the series where the scheduling effort becomes part of each replication remote\u0027s pool\u0027s work.\n\nIs there another way to build confidence around the new low-level constructs? As I showed with the coverage report, they do get tested during the replication tests, but I know that\u0027s not the same as comprehensive testing just for them. Would more testing help? Better (java)docs?\n\n[2] https://gerrit-review.googlesource.com/c/plugins/replication/+/268612",
      "parentUuid": "a090b2b4_c3d98640",
      "range": {
        "startLine": 198,
        "startChar": 0,
        "endLine": 215,
        "endChar": 5
      },
      "revId": "815d1f5626761e03e46e0efb7bc4cf91d8b9732f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8228c09f_1ca27fc3",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationQueue.java",
        "patchSetId": 8
      },
      "lineNbr": 215,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2020-06-30T12:33:56Z",
      "side": 0,
      "message": "\u003e Yes, we definitely could do this and we did consider it. I even backported the changes to support setting defaultThreadPoolSize to 2.7 so that we could potentially do that on our fork (in case it wasn\u0027t clear before, we\u0027ve adapted our 2.7 fork and 3.2 version of the replication plugin to run together). I don\u0027t prefer this as it\u0027s basically saying we have to use more threads.\n\nHere we are talking about (not) using one more thread which loops over pending\nevents and reschedules them. A straightforward synchronous code:\n\n  for t in pendingTasks:\n    schedule(t)\n\nneeds to be rewritten using relatively complex asynchronous code which also\nintroduces many new abstractions. \nWhy is this concept not applied in other places where we have the same\ncoding pattern, for example here [1] or here [2] (and many other places)?\n\n[1] https://gerrit.googlesource.com/gerrit/+/1f7c3856805e8d855ab68f8cfec8c14bf4237c67/java/com/google/gerrit/server/notedb/rebuild/NoteDbMigrator.java#816 \n[2] https://gerrit.googlesource.com/gerrit/+/1f7c3856805e8d855ab68f8cfec8c14bf4237c67/java/com/google/gerrit/server/index/account/AllAccountsIndexer.java#83\n \n\n\u003e Is there another way to build confidence around the new low-level constructs?\n\nThis is not against low-level constructs in general especially if such things\nwould be proposed and discussed on the master branch and if the concept would\nbe applied in the *whole* Gerrit code-base.\n\nBut when such things are introduced in an (old) stable branch of a plugin and used\nonly in that plugin then I suspect this is the reason for many +1s and no\none giving +2 with confidence.",
      "parentUuid": "d7c9eae0_441b3662",
      "range": {
        "startLine": 198,
        "startChar": 0,
        "endLine": 215,
        "endChar": 5
      },
      "revId": "815d1f5626761e03e46e0efb7bc4cf91d8b9732f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7a8a85b2_b78c4c54",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationQueue.java",
        "patchSetId": 8
      },
      "lineNbr": 215,
      "author": {
        "id": 1002666
      },
      "writtenOn": "2020-06-30T16:21:19Z",
      "side": 0,
      "message": "\u003e \u003e Yes, we definitely could do this and we did consider it. I even backported the changes to support setting defaultThreadPoolSize to 2.7 so that we could potentially do that on our fork (in case it wasn\u0027t clear before, we\u0027ve adapted our 2.7 fork and 3.2 version of the replication plugin to run together). I don\u0027t prefer this as it\u0027s basically saying we have to use more threads.\n\u003e \n\u003e Here we are talking about (not) using one more thread which loops over pending\n\u003e events and reschedules them. A straightforward synchronous code:\n\u003e \n\u003e   for t in pendingTasks:\n\u003e     schedule(t)\n\u003e \n\u003e needs to be rewritten using relatively complex asynchronous code which also\n\u003e introduces many new abstractions.\n\nYes. I really wish this was something already implemented in guava or similar that we could just use.\n\n\u003e Why is this concept not applied in other places where we have the same\n\u003e coding pattern, for example here [1] or here [2] (and many other places)?\n\u003e \n\u003e [1] https://gerrit.googlesource.com/gerrit/+/1f7c3856805e8d855ab68f8cfec8c14bf4237c67/java/com/google/gerrit/server/notedb/rebuild/NoteDbMigrator.java#816 \n\u003e [2] https://gerrit.googlesource.com/gerrit/+/1f7c3856805e8d855ab68f8cfec8c14bf4237c67/java/com/google/gerrit/server/index/account/AllAccountsIndexer.java#83\n\nI had actually looked for a few good places to maybe introduce this in Core. Thanks for finding some that look like great candidates!\n\n\u003e  \n\u003e \n\u003e \u003e Is there another way to build confidence around the new low-level constructs?\n\u003e \n\u003e This is not against low-level constructs in general especially if such things\n\u003e would be proposed and discussed on the master branch and if the concept would\n\u003e be applied in the *whole* Gerrit code-base.\n\u003e \n\u003e But when such things are introduced in an (old) stable branch of a plugin and used\n\u003e only in that plugin then I suspect this is the reason for many +1s and no\n\u003e one giving +2 with confidence.\n\nThat\u0027s understandable. If I took the effort to port, for example, NoteDbMigrator to use the ChainedScheduler, I would do that on 2.16 as well (since it really only makes sense there). Would that be more likely to get a +2 and pave the way for this change to move forward (with a refactor to leverage the classes from Core)?",
      "parentUuid": "8228c09f_1ca27fc3",
      "range": {
        "startLine": 198,
        "startChar": 0,
        "endLine": 215,
        "endChar": 5
      },
      "revId": "815d1f5626761e03e46e0efb7bc4cf91d8b9732f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d0f3fa41_05c8c89e",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationQueue.java",
        "patchSetId": 8
      },
      "lineNbr": 215,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2020-07-01T13:54:07Z",
      "side": 0,
      "message": "\u003e \u003e But when such things are introduced in an (old) stable branch of a plugin and used\n\u003e \u003e only in that plugin then I suspect this is the reason for many +1s and no\n\u003e \u003e one giving +2 with confidence.\n\u003e \n\u003e That\u0027s understandable. If I took the effort to port, for example, NoteDbMigrator to use the ChainedScheduler, I would do that on 2.16 as well (since it really only makes sense there).\n\nWhy would we change NoteDbMigrator in stable-2.16? We don\u0027t have P0 issue\nwhich would justify changing that code.\n\nIn the master branch there are also many places with the same coding pattern, for example [1], [2] and [3] so the ChainedScheduler can be discussed there.\n\n[1] https://gerrit.googlesource.com/gerrit/+/refs/heads/master/java/com/google/gerrit/server/index/change/AllChangesIndexer.java#192\n[2] https://gerrit.googlesource.com/gerrit/+/refs/heads/master/java/com/google/gerrit/server/index/project/AllProjectsIndexer.java#75\n[3] https://gerrit.googlesource.com/gerrit/+/refs/heads/master/java/com/google/gerrit/server/index/group/AllGroupsIndexer.java#91\n\n\u003e Would that be more likely to get a +2 and pave the way for this change to move forward (with a refactor to leverage the classes from Core)?\n\nWould this alternative change [4] be a way forward for stable-2.16? It is really\nminimal and it only has one more thread running at the plugin startup for ca 30-45 minutes in your case.\n\n[4] https://gerrit-review.googlesource.com/c/plugins/replication/+/273868",
      "parentUuid": "7a8a85b2_b78c4c54",
      "range": {
        "startLine": 198,
        "startChar": 0,
        "endLine": 215,
        "endChar": 5
      },
      "revId": "815d1f5626761e03e46e0efb7bc4cf91d8b9732f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bfaf4112_d671a0b9",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationQueue.java",
        "patchSetId": 8
      },
      "lineNbr": 215,
      "author": {
        "id": 1011323
      },
      "writtenOn": "2020-07-01T14:08:22Z",
      "side": 0,
      "message": "\u003e Would this alternative change [4] be a way forward for stable-2.16? It is really\nminimal and it only has one more thread running at the plugin startup for ca 30-45 minutes in your case.\n\n+1. We should always prefer minimal invasive approach on very stable branches, and only accept new features on master.",
      "parentUuid": "d0f3fa41_05c8c89e",
      "range": {
        "startLine": 198,
        "startChar": 0,
        "endLine": 215,
        "endChar": 5
      },
      "revId": "815d1f5626761e03e46e0efb7bc4cf91d8b9732f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d5fb8b46_2ec71952",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationQueue.java",
        "patchSetId": 8
      },
      "lineNbr": 215,
      "author": {
        "id": 1014252
      },
      "writtenOn": "2020-07-01T14:25:47Z",
      "side": 0,
      "message": "I concur.",
      "parentUuid": "bfaf4112_d671a0b9",
      "range": {
        "startLine": 198,
        "startChar": 0,
        "endLine": 215,
        "endChar": 5
      },
      "revId": "815d1f5626761e03e46e0efb7bc4cf91d8b9732f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f14c58b7_fded6177",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationQueue.java",
        "patchSetId": 8
      },
      "lineNbr": 215,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2020-07-01T14:28:25Z",
      "side": 0,
      "message": "+1 also to [4]",
      "parentUuid": "d5fb8b46_2ec71952",
      "range": {
        "startLine": 198,
        "startChar": 0,
        "endLine": 215,
        "endChar": 5
      },
      "revId": "815d1f5626761e03e46e0efb7bc4cf91d8b9732f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5886bdd8_cef39b17",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationQueue.java",
        "patchSetId": 8
      },
      "lineNbr": 215,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2020-07-01T18:17:32Z",
      "side": 0,
      "message": "\u003e We should always prefer minimal invasive approach on very stable branches, and only accept new features on master.\n\nClarification, this is NOT a new feature. The new feature was the replicationTaskStorage feature. This change is a bug fix to the regression that introducing that feature caused.",
      "parentUuid": "f14c58b7_fded6177",
      "range": {
        "startLine": 198,
        "startChar": 0,
        "endLine": 215,
        "endChar": 5
      },
      "revId": "815d1f5626761e03e46e0efb7bc4cf91d8b9732f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0ce3fe55_59368da6",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationQueue.java",
        "patchSetId": 8
      },
      "lineNbr": 215,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2020-07-01T18:22:46Z",
      "side": 0,
      "message": "We also already proposed using another thread on this change: https://gerrit-review.googlesource.com/c/plugins/replication/+/258953",
      "parentUuid": "5886bdd8_cef39b17",
      "range": {
        "startLine": 198,
        "startChar": 0,
        "endLine": 215,
        "endChar": 5
      },
      "revId": "815d1f5626761e03e46e0efb7bc4cf91d8b9732f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7a3b2443_4fa876cc",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationQueue.java",
        "patchSetId": 8
      },
      "lineNbr": 215,
      "author": {
        "id": 1011323
      },
      "writtenOn": "2020-07-01T18:54:16Z",
      "side": 0,
      "message": "\u003e \u003e We should always prefer minimal invasive approach on very stable branches, and only accept new features on master.\n\u003e Clarification, this is NOT a new feature. The new feature was the replicationTaskStorage feature. This change is a bug fix to the regression that introducing that feature caused.\n\nMy comment wasn\u0027t accurate: We should always prefer minimal invasive approach for fixing bugs on very stable branches. We should defer all new concepts to the master branch only. And I also agree with Saša: bring ChainedScheduler concept to gerrit core on master, so that more reviewers would provide feedback.",
      "parentUuid": "0ce3fe55_59368da6",
      "range": {
        "startLine": 198,
        "startChar": 0,
        "endLine": 215,
        "endChar": 5
      },
      "revId": "815d1f5626761e03e46e0efb7bc4cf91d8b9732f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "df364367_499d7de2",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationQueue.java",
        "patchSetId": 8
      },
      "lineNbr": 215,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2020-07-01T19:03:25Z",
      "side": 0,
      "message": "\u003e \u003e \u003e We should always prefer minimal invasive approach on very stable branches, and only accept new features on master.\n\u003e \u003e Clarification, this is NOT a new feature. The new feature was the replicationTaskStorage feature. This change is a bug fix to the regression that introducing that feature caused.\n\u003e \n\u003e My comment wasn\u0027t accurate: We should always prefer minimal invasive approach for fixing bugs on very stable branches. We should defer all new concepts to the master branch only. And I also agree with Saša: bring ChainedScheduler concept to gerrit core on master, so that more reviewers would provide feedback.\n\n\nThanks. Is there a reason it would need to be in core first, why not on the master branch for the replication plugin (or any other plugin, this is something that the WebSessions and batch cleaners could use)?",
      "parentUuid": "7a3b2443_4fa876cc",
      "range": {
        "startLine": 198,
        "startChar": 0,
        "endLine": 215,
        "endChar": 5
      },
      "revId": "815d1f5626761e03e46e0efb7bc4cf91d8b9732f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e951fe19_743350fc",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationQueue.java",
        "patchSetId": 8
      },
      "lineNbr": 215,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2020-07-01T19:09:25Z",
      "side": 0,
      "message": "\u003e \u003e My comment wasn\u0027t accurate: We should always prefer minimal invasive approach for fixing bugs on very stable branches. We should defer all new concepts to the master branch only. And I also agree with Saša: bring ChainedScheduler concept to gerrit core on master, so that more reviewers would provide feedback.\n\u003e \n\u003e \n\u003e Thanks. Is there a reason it would need to be in core first, why not on the master branch for the replication plugin (or any other plugin, this is something that the WebSessions and batch cleaners could use)?\n\nIt seems less risky to me to develop such a concept in a plugin before bringing it to core?",
      "parentUuid": "df364367_499d7de2",
      "range": {
        "startLine": 198,
        "startChar": 0,
        "endLine": 215,
        "endChar": 5
      },
      "revId": "815d1f5626761e03e46e0efb7bc4cf91d8b9732f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1ad69a5b_8941f908",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationQueue.java",
        "patchSetId": 8
      },
      "lineNbr": 215,
      "author": {
        "id": 1011323
      },
      "writtenOn": "2020-07-01T19:33:52Z",
      "side": 0,
      "message": "The opposite is the case. There are another couple of Gerrit stakeholder / maintainers that don\u0027t use replication (or websession-flatfile) plugin and wouldn\u0027t be interested to review any changes here. As Saša pointed out, similar concepts in gerrit core could use similar scheduling approach. That way new concepts implemented in core would be more reliable, battle hardened implementations. To put it even more drastically: let\u0027s break gerrit core before we break replication or any other core plugins (not to mention breaking the core plugin on most stable or even EOL branches).\n\nIn fact, a good example of adding new concepts even on master branch didn\u0027t help, if there is not enough time for testing and iron out the implementation, and the new concept had to be reverted, because it wasn\u0027t stable enough to be shipped on stable-3.2 release: [1], [2].\n\n[1] https://gerrit-review.googlesource.com/c/plugins/replication/+/241132\n[2] https://gerrit-review.googlesource.com/c/plugins/replication/+/272612",
      "parentUuid": "e951fe19_743350fc",
      "range": {
        "startLine": 198,
        "startChar": 0,
        "endLine": 215,
        "endChar": 5
      },
      "revId": "815d1f5626761e03e46e0efb7bc4cf91d8b9732f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2d4da223_6a16aa19",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationQueue.java",
        "patchSetId": 8
      },
      "lineNbr": 215,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2020-07-01T19:46:50Z",
      "side": 0,
      "message": "\u003e The opposite is the case. There are another couple of Gerrit stakeholder / maintainers that don\u0027t use replication (or websession-flatfile) plugin and wouldn\u0027t be interested to review any changes here.\n\nI don\u0027t think that is relevant unless it affects core.\n\n\u003e As Saša pointed out, similar concepts in gerrit core could use similar scheduling approach. That way new concepts implemented in core would be more reliable, battle hardened implementations.\n\nThis is potentially true, and I welcome it in core.\n\n\u003e To put it even more drastically: let\u0027s break gerrit core before we break replication or any other core plugins (not to mention breaking the core plugin on most stable or even EOL branches).\n\nAs a maintainer, I would favor bringing into core things that have already proven themselves from plugins. And if I took that one step further, I would favor bringing stuff into core-plugins from non-core plugins first given the choice.\n\n\u003e In fact, a good example of adding new concepts even on master branch didn\u0027t help, if there is not enough time for testing and iron out the implementation, and the new concept had to be reverted, because it wasn\u0027t stable enough to be shipped on stable-3.2 release: [1], [2].\n\u003e \n\u003e [1] https://gerrit-review.googlesource.com/c/plugins/replication/+/241132\n\u003e [2] https://gerrit-review.googlesource.com/c/plugins/replication/+/272612\n\nI don\u0027t understand how that feature is relevant to the discussion since that was not a feature that could be brought into core?",
      "parentUuid": "1ad69a5b_8941f908",
      "range": {
        "startLine": 198,
        "startChar": 0,
        "endLine": 215,
        "endChar": 5
      },
      "revId": "815d1f5626761e03e46e0efb7bc4cf91d8b9732f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7527ba42_80d1d196",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationQueue.java",
        "patchSetId": 8
      },
      "lineNbr": 215,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2020-07-02T12:32:47Z",
      "side": 0,
      "message": "Besides what David already mentioned here is my main main reason why I would like to\nhave the ChainedScheduler discussed and reviewed in master and ideally in Gerrit core:\nCode Readability.\n\nIf we take 10 random developers and show them the two version of the code,\nBase vs PS-8 or I224c2ce2a35f987af2343089b9bb00a7fcb7e3be vs PS-8,\nand ask them to understand what this code is doing I bet that 10 of 10 would need\nsignificantly longer time for the code which uses ChainedScheduler.\nI believe that code readability is also an important feature of the Gerrit project and\nit is important to get an opinion from most of the maintainers about replacing\na code like:\n\n  for m in collection:\n    executor.submit(m)\n\nwith asynchronous code like in PS-8 in order to save one thread for the duration of\nthe loop.",
      "parentUuid": "2d4da223_6a16aa19",
      "range": {
        "startLine": 198,
        "startChar": 0,
        "endLine": 215,
        "endChar": 5
      },
      "revId": "815d1f5626761e03e46e0efb7bc4cf91d8b9732f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "205ab3e2_9ecfa3d1",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationQueue.java",
        "patchSetId": 8
      },
      "lineNbr": 215,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2020-07-02T18:59:23Z",
      "side": 0,
      "message": "\u003e Besides what David already mentioned here is my main main reason why I would like to have the ChainedScheduler discussed and reviewed in master and ideally in Gerrit core:\n\nUnfortunately I don\u0027t know if we have any clear guidance as a community on the issue of where such new concepts should be introduced. While as a maintainer (not the author of this change) I don\u0027t agree with that stance, I am fine with it if this is the path the community wants. Since it feels mostly like a process kind of discussion, do you think this is something that we should ask input from the ESC on so that we can have an agreed upon path in the future?\n\n\u003e Code Readability.\n\u003e \n\u003e If we take 10 random developers and show them the two version of the code,\n\u003e Base vs PS-8 or I224c2ce2a35f987af2343089b9bb00a7fcb7e3be vs PS-8,\n\u003e and ask them to understand what this code is doing I bet that 10 of 10 would need\n\u003e significantly longer time for the code which uses ChainedScheduler.\n\u003e I believe that code readability is also an important feature of the Gerrit project and\n\u003e it is important to get an opinion from most of the maintainers about replacing\n\u003e a code like:\n\u003e \n\u003e   for m in collection:\n\u003e     executor.submit(m)\n\u003e \n\u003e with asynchronous code like in PS-8 \n\nI am not sure I understand the concern here. Of course, I am not going to claim that this is as simple as a for loop, it isn\u0027t. The concept is more advanced, it is more comparable to the complexity of using an executor. What specifically is your concern, is it 1) that this code is not readable for the task it is achieving? 2) the task it is achieving is not worth the complexity? 3) The complexity is not worth it on this branch?\n\n\u003e in order to save one thread for the duration of the loop.\n\nWhile it does \"save one thread\", it also prevents the queue from being filled with potentially 100K entries that will delay all current updates which helps prevent the reduction of priority of current updates.",
      "parentUuid": "7527ba42_80d1d196",
      "range": {
        "startLine": 198,
        "startChar": 0,
        "endLine": 215,
        "endChar": 5
      },
      "revId": "815d1f5626761e03e46e0efb7bc4cf91d8b9732f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "023cda98_fe375296",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationQueue.java",
        "patchSetId": 8
      },
      "lineNbr": 215,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2020-07-08T15:18:35Z",
      "side": 0,
      "message": "Sorry for a longer delay in the discussion, we had an incident in production\nwhich took a couple of days to follow-up, understand and cleanup.\n\n\u003e \u003e it is important to get an opinion from most of the maintainers about replacing\n\u003e \u003e a code like:\n\u003e \u003e \n\u003e \u003e   for m in collection:\n\u003e \u003e     executor.submit(m)\n\u003e \u003e \n\u003e \u003e with asynchronous code like in PS-8 \n\u003e \n\u003e I am not sure I understand the concern here. Of course, I am not going to claim that this is as simple as a for loop, it isn\u0027t. The concept is more advanced, it is more comparable to the complexity of using an executor. What specifically is your concern, is it 1) that this code is not readable for the task it is achieving? 2) the task it is achieving is not worth the complexity? 3) The complexity is not worth it on this branch?\n\u003e \n\u003e \u003e in order to save one thread for the duration of the loop.\n\u003e \n\u003e While it does \"save one thread\", it also prevents the queue from being filled with potentially 100K entries that will delay all current updates which helps prevent the reduction of priority of current updates.\n\nThinking again about what you wrote I realize that this change is actually\ndoing two things:\n1 move the rescheduling of the pending tasks in the background\n2 lowers priority of the pending tasks (compared to current replication tasks)\n\nI believe that we all agree on 1. But we implicitly get 2 in the context\nof implementing 1, without a dedicated change where this design decision\nis discussed.\n\nIf replication of change c1 is pending at the moment when the replication plugin\nstarts, and then change c2 gets uploaded shortly after the replication plugin\nis ready, the replication of c2 will have potentially (depending on the number of pending tasks) much higher priority. It may happen that c1 gets replicated\nfor example 30 minutes later than c2.\n\nDo we have agreement on 2? Maybe I missed some discussion.",
      "parentUuid": "205ab3e2_9ecfa3d1",
      "range": {
        "startLine": 198,
        "startChar": 0,
        "endLine": 215,
        "endChar": 5
      },
      "revId": "815d1f5626761e03e46e0efb7bc4cf91d8b9732f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8c02e7df_8dcf7ce0",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationQueue.java",
        "patchSetId": 8
      },
      "lineNbr": 215,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2020-07-08T17:04:15Z",
      "side": 0,
      "message": "\u003e \u003e \u003e in order to save one thread for the duration of the loop.\n\u003e \u003e \n\u003e \u003e While it does \"save one thread\", it also prevents the queue from being filled with potentially 100K entries that will delay all current updates which helps prevent the reduction of priority of current updates.\n\nI am sorry, this explanation was wrong, I miss-lead the discussion with it. This explanation applies to https://gerrit-review.googlesource.com/c/plugins/replication/+/268612/2 and not to the current change. With this change, the queue can still get filled with 100K pending entries that will delay newly created events.\n\n\u003e 2 lowers priority of the pending tasks (compared to current replication tasks)\n\u003e \n\u003e I believe that we all agree on 1. But we implicitly get 2 in the context\n\u003e of implementing 1, without a dedicated change where this design decision\n\u003e is discussed.\n\nWhile I do want #2, it is not specifically targeted by this change and priority is not explicitly lowered with respect to other replication tasks in this change.\n\n\u003e If replication of change c1 is pending at the moment when the replication plugin\n\u003e starts, and then change c2 gets uploaded shortly after the replication plugin\n\u003e is ready, the replication of c2 will have potentially (depending on the number of pending tasks) much higher priority. It may happen that c1 gets replicated\n\u003e for example 30 minutes later than c2.\n\nDespite my miss-direction, you are correct about this scenario being possible, but that is because the replication plugin no longer waits for all the pending events to be read from disk, and if it takes a long time to read C1 in the background threads, then C2 can get executed before C1 is ever read. With this change, there is a priority reduction which happens in the default queue (but not in the replication queues), and that reduction is to reduce the priority of reading and scheduling replication tasks compared to all other non-replication tasks which may be in the default queue.\n\n\u003e Do we have agreement on 2?\n\nNot quite, sorry for the miss-direction in my previous reply.",
      "parentUuid": "023cda98_fe375296",
      "range": {
        "startLine": 198,
        "startChar": 0,
        "endLine": 215,
        "endChar": 5
      },
      "revId": "815d1f5626761e03e46e0efb7bc4cf91d8b9732f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ed4b5b72_5b3974af",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationQueue.java",
        "patchSetId": 8
      },
      "lineNbr": 215,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2020-07-13T16:20:04Z",
      "side": 0,
      "message": "\u003e \u003e \u003e \u003e in order to save one thread for the duration of the loop.\n\u003e \u003e \u003e \n\u003e \u003e \u003e While it does \"save one thread\", it also prevents the queue from being filled with potentially 100K entries that will delay all current updates which helps prevent the reduction of priority of current updates.\n\u003e \n\u003e I am sorry, this explanation was wrong, I miss-lead the discussion with it. This explanation applies to https://gerrit-review.googlesource.com/c/plugins/replication/+/268612/2 and not to the current change. With this change, the queue can still get filled with 100K pending entries that will delay newly created events.\n\nWhy then prefer a complex code like ChainedScheduler, over the approach in [4]?\n\nI am sorry for still not being able to approve this change and I admit that I still\ndo not fully grasp the ChainedScheduler code (which might indeed be a master piece).\n\n[4] https://gerrit-review.googlesource.com/c/plugins/replication/+/273868\n\n\u003e \n\u003e \u003e 2 lowers priority of the pending tasks (compared to current replication tasks)\n\u003e \u003e \n\u003e \u003e I believe that we all agree on 1. But we implicitly get 2 in the context\n\u003e \u003e of implementing 1, without a dedicated change where this design decision\n\u003e \u003e is discussed.\n\u003e \n\u003e While I do want #2, it is not specifically targeted by this change and priority is not explicitly lowered with respect to other replication tasks in this change.\n\u003e \n\u003e \u003e If replication of change c1 is pending at the moment when the replication plugin\n\u003e \u003e starts, and then change c2 gets uploaded shortly after the replication plugin\n\u003e \u003e is ready, the replication of c2 will have potentially (depending on the number of pending tasks) much higher priority. It may happen that c1 gets replicated\n\u003e \u003e for example 30 minutes later than c2.\n\u003e \n\u003e Despite my miss-direction, you are correct about this scenario being possible, but that is because the replication plugin no longer waits for all the pending events to be read from disk, and if it takes a long time to read C1 in the background threads, then C2 can get executed before C1 is ever read. With this change, there is a priority reduction which happens in the default queue (but not in the replication queues), and that reduction is to reduce the priority of reading and scheduling replication tasks compared to all other non-replication tasks which may be in the default queue.\n\u003e \n\u003e \u003e Do we have agreement on 2?\n\u003e \n\u003e Not quite, sorry for the miss-direction in my previous reply.",
      "parentUuid": "8c02e7df_8dcf7ce0",
      "range": {
        "startLine": 198,
        "startChar": 0,
        "endLine": 215,
        "endChar": 5
      },
      "revId": "815d1f5626761e03e46e0efb7bc4cf91d8b9732f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f732c1b5_ff418464",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationQueue.java",
        "patchSetId": 8
      },
      "lineNbr": 215,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2020-07-13T18:03:23Z",
      "side": 0,
      "message": "\u003e \u003e \u003e \u003e \u003e in order to save one thread for the duration of the loop.\n\u003e \u003e \u003e \u003e \n\u003e \u003e \u003e \u003e While it does \"save one thread\", it also prevents the queue from being filled with potentially 100K entries that will delay all current updates which helps prevent the reduction of priority of current updates.\n\u003e \u003e \n\u003e \u003e I am sorry, this explanation was wrong, I miss-lead the discussion with it. This explanation applies to https://gerrit-review.googlesource.com/c/plugins/replication/+/268612/2 and not to the current change. With this change, the queue can still get filled with 100K pending entries that will delay newly created events.\n\u003e \n\u003e Why then prefer a complex code like ChainedScheduler, over the approach in [4]?\n\u003e \n\u003e I am sorry for still not being able to approve this change and I admit that I still\n\u003e do not fully grasp the ChainedScheduler code (which might indeed be a master piece).\n\u003e \n\u003e [4] https://gerrit-review.googlesource.com/c/plugins/replication/+/273868\n\nWhy then prefer a complex code like ChainedScheduler, over the approach in [4]?\n\nThe primary advantage over #4 (aside from the issues already mentioned in the review comments on that change), is that it does not require any extra threads. I do think it is important to stop the proliferation of extra threads, as each new thread lowers the priority of all existing threads and ultimately impacts the scalability of the system.\n\nTo summarize those 3 options and my understanding of the downsides:\n\n1) Use a chained scheduler -\u003e some extra complexity\n2) Use a new separate thread pool -\u003e extra thread proliferation\n3) Use an existing thread pool, bump the threads -\u003e extra thread proliferation \n4) Use an existing thread pool, no thread bump \u003e starvation of existing tasks\n\nI believe the above is true whether on a stable branch, or on the master branch. Perhaps it would help to decide what we want on the master branch first, and then decide how to achieve that?\n\n\u003e I am sorry for still not being able to approve this change and I admit that I still do not fully grasp the ChainedScheduler code (which might indeed be a master piece).\n\nFirst, let me make it clear that I very much appreciate your review!! I want someone to understand the technical implications and to criticize them. So, thank you very much for rewording what you think is happening, and getting me to clarify things to help clear up any miss-understandings and to get us on the same page first. I think that is vital before anyone can judge anything else about the change.\n\nI think the difficulty here is that there is no perfect simple solution without any downsides. I think we need to pick a \"good\" solution and not let \"perfect\" be the enemy of good. If this were a fix for master, I would argue extremely strongly for solution #1 as I believe that the extra complexity is needed and worth it to make our system begin to scale better. I also understand the appeal of not having extra complexity on a stable branch, however I am not sure the other downsides are good ones for a stable branch either, and it seems silly to just add those downsides to the stable branch to only later remove it on the master branch for a better solution, particularly because I don\u0027t think the complexity is that huge, and it is easily testable.",
      "parentUuid": "ed4b5b72_5b3974af",
      "range": {
        "startLine": 198,
        "startChar": 0,
        "endLine": 215,
        "endChar": 5
      },
      "revId": "815d1f5626761e03e46e0efb7bc4cf91d8b9732f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0cd9832f_f418ebe6",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationQueue.java",
        "patchSetId": 8
      },
      "lineNbr": 215,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2020-10-28T22:58:02Z",
      "side": 0,
      "message": "Ack",
      "parentUuid": "f732c1b5_ff418464",
      "range": {
        "startLine": 198,
        "startChar": 0,
        "endLine": 215,
        "endChar": 5
      },
      "revId": "815d1f5626761e03e46e0efb7bc4cf91d8b9732f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    }
  ]
}