{
  "comments": [
    {
      "key": {
        "uuid": "a090b2b4_c3d98640",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationQueue.java",
        "patchSetId": 8
      },
      "lineNbr": 215,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2020-06-29T14:00:55Z",
      "side": 0,
      "message": "Let me try to move discussion on this change forward by first describing my understanding of this change. The main problem here is that this code snippet (firePendingEvents) is executed\nsynchronously, from that calling thread. When there are thousands of events to reschedule this can take a lot of time (at least in Qualcomm\u0027s case).\n\nThe proposed solution in this change is to move scheduling into background so that the start() method returns as fast as possible and that the replication plugin can start processing events.\nSo far, I believe that everyone agrees on the proposed concept :-)\n\nBesides moving this code into background this change also tries to act non-invasively on the default queue. This means that it wants to keep a thread from the default queue busy only\nfor a short time needed to schedule one task and then schedule the next task. To achieve that\nit introduced the concepts of: ChainedScheduled, Runner, DecoratedRunner, StreamScheduler, etc.. This code defines decorated tasks with the onDone callback used to schedule the next task. The code seems to be technically correct but it also introduces a lot of new low-level\nconstructs which makes reviewers unsure whether to submit this change.\n\nAs an alternative possibility I would like to propose the following: what if the firePendingEvents method is executed whole as one task in the default queue?\nIt is definitely more invasive towards the default queue as it would keep one thread busy\nuntil all pending tasks are rescheduled. However, if this is really an issue we can\nsimply increase the size of the default queue by one, see execution.defaultThreadPoolSize [1].\nThis solution is technically not as good as the one proposed in this change but we don\u0027t\nend up with several new low-level constructs (listed above).\n\nWDYT?\n\n[1] https://gerrit-review.googlesource.com/Documentation/config-gerrit.html#execution.defaultThreadPoolSize",
      "range": {
        "startLine": 198,
        "startChar": 0,
        "endLine": 215,
        "endChar": 5
      },
      "revId": "815d1f5626761e03e46e0efb7bc4cf91d8b9732f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d7c9eae0_441b3662",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationQueue.java",
        "patchSetId": 8
      },
      "lineNbr": 215,
      "author": {
        "id": 1002666
      },
      "writtenOn": "2020-06-29T18:52:59Z",
      "side": 0,
      "message": "[snip]\n\nThanks for this summary Saša!\n\n\u003e As an alternative possibility I would like to propose the following: what if the firePendingEvents method is executed whole as one task in the default queue?\n\u003e It is definitely more invasive towards the default queue as it would keep one thread busy\n\u003e until all pending tasks are rescheduled. However, if this is really an issue we can\n\u003e simply increase the size of the default queue by one, see execution.defaultThreadPoolSize [1].\n\u003e This solution is technically not as good as the one proposed in this change but we don\u0027t\n\u003e end up with several new low-level constructs (listed above).\n\u003e \n\u003e WDYT?\n\nYes, we definitely could do this and we did consider it. I even backported the changes to support setting defaultThreadPoolSize to 2.7 so that we could potentially do that on our fork (in case it wasn\u0027t clear before, we\u0027ve adapted our 2.7 fork and 3.2 version of the replication plugin to run together). I don\u0027t prefer this as it\u0027s basically saying we have to use more threads.\n\nThis also doesn\u0027t provide a path to the next change [2] in the series where the scheduling effort becomes part of each replication remote\u0027s pool\u0027s work.\n\nIs there another way to build confidence around the new low-level constructs? As I showed with the coverage report, they do get tested during the replication tests, but I know that\u0027s not the same as comprehensive testing just for them. Would more testing help? Better (java)docs?\n\n[2] https://gerrit-review.googlesource.com/c/plugins/replication/+/268612",
      "parentUuid": "a090b2b4_c3d98640",
      "range": {
        "startLine": 198,
        "startChar": 0,
        "endLine": 215,
        "endChar": 5
      },
      "revId": "815d1f5626761e03e46e0efb7bc4cf91d8b9732f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8228c09f_1ca27fc3",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationQueue.java",
        "patchSetId": 8
      },
      "lineNbr": 215,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2020-06-30T12:33:56Z",
      "side": 0,
      "message": "\u003e Yes, we definitely could do this and we did consider it. I even backported the changes to support setting defaultThreadPoolSize to 2.7 so that we could potentially do that on our fork (in case it wasn\u0027t clear before, we\u0027ve adapted our 2.7 fork and 3.2 version of the replication plugin to run together). I don\u0027t prefer this as it\u0027s basically saying we have to use more threads.\n\nHere we are talking about (not) using one more thread which loops over pending\nevents and reschedules them. A straightforward synchronous code:\n\n  for t in pendingTasks:\n    schedule(t)\n\nneeds to be rewritten using relatively complex asynchronous code which also\nintroduces many new abstractions. \nWhy is this concept not applied in other places where we have the same\ncoding pattern, for example here [1] or here [2] (and many other places)?\n\n[1] https://gerrit.googlesource.com/gerrit/+/1f7c3856805e8d855ab68f8cfec8c14bf4237c67/java/com/google/gerrit/server/notedb/rebuild/NoteDbMigrator.java#816 \n[2] https://gerrit.googlesource.com/gerrit/+/1f7c3856805e8d855ab68f8cfec8c14bf4237c67/java/com/google/gerrit/server/index/account/AllAccountsIndexer.java#83\n \n\n\u003e Is there another way to build confidence around the new low-level constructs?\n\nThis is not against low-level constructs in general especially if such things\nwould be proposed and discussed on the master branch and if the concept would\nbe applied in the *whole* Gerrit code-base.\n\nBut when such things are introduced in an (old) stable branch of a plugin and used\nonly in that plugin then I suspect this is the reason for many +1s and no\none giving +2 with confidence.",
      "parentUuid": "d7c9eae0_441b3662",
      "range": {
        "startLine": 198,
        "startChar": 0,
        "endLine": 215,
        "endChar": 5
      },
      "revId": "815d1f5626761e03e46e0efb7bc4cf91d8b9732f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7a8a85b2_b78c4c54",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationQueue.java",
        "patchSetId": 8
      },
      "lineNbr": 215,
      "author": {
        "id": 1002666
      },
      "writtenOn": "2020-06-30T16:21:19Z",
      "side": 0,
      "message": "\u003e \u003e Yes, we definitely could do this and we did consider it. I even backported the changes to support setting defaultThreadPoolSize to 2.7 so that we could potentially do that on our fork (in case it wasn\u0027t clear before, we\u0027ve adapted our 2.7 fork and 3.2 version of the replication plugin to run together). I don\u0027t prefer this as it\u0027s basically saying we have to use more threads.\n\u003e \n\u003e Here we are talking about (not) using one more thread which loops over pending\n\u003e events and reschedules them. A straightforward synchronous code:\n\u003e \n\u003e   for t in pendingTasks:\n\u003e     schedule(t)\n\u003e \n\u003e needs to be rewritten using relatively complex asynchronous code which also\n\u003e introduces many new abstractions.\n\nYes. I really wish this was something already implemented in guava or similar that we could just use.\n\n\u003e Why is this concept not applied in other places where we have the same\n\u003e coding pattern, for example here [1] or here [2] (and many other places)?\n\u003e \n\u003e [1] https://gerrit.googlesource.com/gerrit/+/1f7c3856805e8d855ab68f8cfec8c14bf4237c67/java/com/google/gerrit/server/notedb/rebuild/NoteDbMigrator.java#816 \n\u003e [2] https://gerrit.googlesource.com/gerrit/+/1f7c3856805e8d855ab68f8cfec8c14bf4237c67/java/com/google/gerrit/server/index/account/AllAccountsIndexer.java#83\n\nI had actually looked for a few good places to maybe introduce this in Core. Thanks for finding some that look like great candidates!\n\n\u003e  \n\u003e \n\u003e \u003e Is there another way to build confidence around the new low-level constructs?\n\u003e \n\u003e This is not against low-level constructs in general especially if such things\n\u003e would be proposed and discussed on the master branch and if the concept would\n\u003e be applied in the *whole* Gerrit code-base.\n\u003e \n\u003e But when such things are introduced in an (old) stable branch of a plugin and used\n\u003e only in that plugin then I suspect this is the reason for many +1s and no\n\u003e one giving +2 with confidence.\n\nThat\u0027s understandable. If I took the effort to port, for example, NoteDbMigrator to use the ChainedScheduler, I would do that on 2.16 as well (since it really only makes sense there). Would that be more likely to get a +2 and pave the way for this change to move forward (with a refactor to leverage the classes from Core)?",
      "parentUuid": "8228c09f_1ca27fc3",
      "range": {
        "startLine": 198,
        "startChar": 0,
        "endLine": 215,
        "endChar": 5
      },
      "revId": "815d1f5626761e03e46e0efb7bc4cf91d8b9732f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d0f3fa41_05c8c89e",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationQueue.java",
        "patchSetId": 8
      },
      "lineNbr": 215,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2020-07-01T13:54:07Z",
      "side": 0,
      "message": "\u003e \u003e But when such things are introduced in an (old) stable branch of a plugin and used\n\u003e \u003e only in that plugin then I suspect this is the reason for many +1s and no\n\u003e \u003e one giving +2 with confidence.\n\u003e \n\u003e That\u0027s understandable. If I took the effort to port, for example, NoteDbMigrator to use the ChainedScheduler, I would do that on 2.16 as well (since it really only makes sense there).\n\nWhy would we change NoteDbMigrator in stable-2.16? We don\u0027t have P0 issue\nwhich would justify changing that code.\n\nIn the master branch there are also many places with the same coding pattern, for example [1], [2] and [3] so the ChainedScheduler can be discussed there.\n\n[1] https://gerrit.googlesource.com/gerrit/+/refs/heads/master/java/com/google/gerrit/server/index/change/AllChangesIndexer.java#192\n[2] https://gerrit.googlesource.com/gerrit/+/refs/heads/master/java/com/google/gerrit/server/index/project/AllProjectsIndexer.java#75\n[3] https://gerrit.googlesource.com/gerrit/+/refs/heads/master/java/com/google/gerrit/server/index/group/AllGroupsIndexer.java#91\n\n\u003e Would that be more likely to get a +2 and pave the way for this change to move forward (with a refactor to leverage the classes from Core)?\n\nWould this alternative change [4] be a way forward for stable-2.16? It is really\nminimal and it only has one more thread running at the plugin startup for ca 30-45 minutes in your case.\n\n[4] https://gerrit-review.googlesource.com/c/plugins/replication/+/273868",
      "parentUuid": "7a8a85b2_b78c4c54",
      "range": {
        "startLine": 198,
        "startChar": 0,
        "endLine": 215,
        "endChar": 5
      },
      "revId": "815d1f5626761e03e46e0efb7bc4cf91d8b9732f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bfaf4112_d671a0b9",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationQueue.java",
        "patchSetId": 8
      },
      "lineNbr": 215,
      "author": {
        "id": 1011323
      },
      "writtenOn": "2020-07-01T14:08:22Z",
      "side": 0,
      "message": "\u003e Would this alternative change [4] be a way forward for stable-2.16? It is really\nminimal and it only has one more thread running at the plugin startup for ca 30-45 minutes in your case.\n\n+1. We should always prefer minimal invasive approach on very stable branches, and only accept new features on master.",
      "parentUuid": "d0f3fa41_05c8c89e",
      "range": {
        "startLine": 198,
        "startChar": 0,
        "endLine": 215,
        "endChar": 5
      },
      "revId": "815d1f5626761e03e46e0efb7bc4cf91d8b9732f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d5fb8b46_2ec71952",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationQueue.java",
        "patchSetId": 8
      },
      "lineNbr": 215,
      "author": {
        "id": 1014252
      },
      "writtenOn": "2020-07-01T14:25:47Z",
      "side": 0,
      "message": "I concur.",
      "parentUuid": "bfaf4112_d671a0b9",
      "range": {
        "startLine": 198,
        "startChar": 0,
        "endLine": 215,
        "endChar": 5
      },
      "revId": "815d1f5626761e03e46e0efb7bc4cf91d8b9732f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f14c58b7_fded6177",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationQueue.java",
        "patchSetId": 8
      },
      "lineNbr": 215,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2020-07-01T14:28:25Z",
      "side": 0,
      "message": "+1 also to [4]",
      "parentUuid": "d5fb8b46_2ec71952",
      "range": {
        "startLine": 198,
        "startChar": 0,
        "endLine": 215,
        "endChar": 5
      },
      "revId": "815d1f5626761e03e46e0efb7bc4cf91d8b9732f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5886bdd8_cef39b17",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationQueue.java",
        "patchSetId": 8
      },
      "lineNbr": 215,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2020-07-01T18:17:32Z",
      "side": 0,
      "message": "\u003e We should always prefer minimal invasive approach on very stable branches, and only accept new features on master.\n\nClarification, this is NOT a new feature. The new feature was the replicationTaskStorage feature. This change is a bug fix to the regression that introducing that feature caused.",
      "parentUuid": "f14c58b7_fded6177",
      "range": {
        "startLine": 198,
        "startChar": 0,
        "endLine": 215,
        "endChar": 5
      },
      "revId": "815d1f5626761e03e46e0efb7bc4cf91d8b9732f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0ce3fe55_59368da6",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationQueue.java",
        "patchSetId": 8
      },
      "lineNbr": 215,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2020-07-01T18:22:46Z",
      "side": 0,
      "message": "We also already proposed using another thread on this change: https://gerrit-review.googlesource.com/c/plugins/replication/+/258953",
      "parentUuid": "5886bdd8_cef39b17",
      "range": {
        "startLine": 198,
        "startChar": 0,
        "endLine": 215,
        "endChar": 5
      },
      "revId": "815d1f5626761e03e46e0efb7bc4cf91d8b9732f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7a3b2443_4fa876cc",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationQueue.java",
        "patchSetId": 8
      },
      "lineNbr": 215,
      "author": {
        "id": 1011323
      },
      "writtenOn": "2020-07-01T18:54:16Z",
      "side": 0,
      "message": "\u003e \u003e We should always prefer minimal invasive approach on very stable branches, and only accept new features on master.\n\u003e Clarification, this is NOT a new feature. The new feature was the replicationTaskStorage feature. This change is a bug fix to the regression that introducing that feature caused.\n\nMy comment wasn\u0027t accurate: We should always prefer minimal invasive approach for fixing bugs on very stable branches. We should defer all new concepts to the master branch only. And I also agree with Saša: bring ChainedScheduler concept to gerrit core on master, so that more reviewers would provide feedback.",
      "parentUuid": "0ce3fe55_59368da6",
      "range": {
        "startLine": 198,
        "startChar": 0,
        "endLine": 215,
        "endChar": 5
      },
      "revId": "815d1f5626761e03e46e0efb7bc4cf91d8b9732f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "df364367_499d7de2",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationQueue.java",
        "patchSetId": 8
      },
      "lineNbr": 215,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2020-07-01T19:03:25Z",
      "side": 0,
      "message": "\u003e \u003e \u003e We should always prefer minimal invasive approach on very stable branches, and only accept new features on master.\n\u003e \u003e Clarification, this is NOT a new feature. The new feature was the replicationTaskStorage feature. This change is a bug fix to the regression that introducing that feature caused.\n\u003e \n\u003e My comment wasn\u0027t accurate: We should always prefer minimal invasive approach for fixing bugs on very stable branches. We should defer all new concepts to the master branch only. And I also agree with Saša: bring ChainedScheduler concept to gerrit core on master, so that more reviewers would provide feedback.\n\n\nThanks. Is there a reason it would need to be in core first, why not on the master branch for the replication plugin (or any other plugin, this is something that the WebSessions and batch cleaners could use)?",
      "parentUuid": "7a3b2443_4fa876cc",
      "range": {
        "startLine": 198,
        "startChar": 0,
        "endLine": 215,
        "endChar": 5
      },
      "revId": "815d1f5626761e03e46e0efb7bc4cf91d8b9732f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e951fe19_743350fc",
        "filename": "src/main/java/com/googlesource/gerrit/plugins/replication/ReplicationQueue.java",
        "patchSetId": 8
      },
      "lineNbr": 215,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2020-07-01T19:09:25Z",
      "side": 0,
      "message": "\u003e \u003e My comment wasn\u0027t accurate: We should always prefer minimal invasive approach for fixing bugs on very stable branches. We should defer all new concepts to the master branch only. And I also agree with Saša: bring ChainedScheduler concept to gerrit core on master, so that more reviewers would provide feedback.\n\u003e \n\u003e \n\u003e Thanks. Is there a reason it would need to be in core first, why not on the master branch for the replication plugin (or any other plugin, this is something that the WebSessions and batch cleaners could use)?\n\nIt seems less risky to me to develop such a concept in a plugin before bringing it to core?",
      "parentUuid": "df364367_499d7de2",
      "range": {
        "startLine": 198,
        "startChar": 0,
        "endLine": 215,
        "endChar": 5
      },
      "revId": "815d1f5626761e03e46e0efb7bc4cf91d8b9732f",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    }
  ]
}